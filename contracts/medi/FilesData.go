// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package medi

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// FilesDataABI is the input ABI used to generate the binding from.
const FilesDataABI = "[{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"getUploaderUuid\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"},{\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setActive\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"},{\"name\":\"fileType\",\"type\":\"bytes32\"}],\"name\":\"setFileType\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"},{\"name\":\"ownerUuid\",\"type\":\"bytes16\"}],\"name\":\"setOwnerUuid\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSuperSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getFileSignerUuidByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setTime\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"getOwnerUuid\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"getFileSignerSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"keccak256Hash\",\"type\":\"bytes32\"}],\"name\":\"getUuidByKeccak256Hash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"delSuper\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUuidListSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"},{\"name\":\"uploaderUuid\",\"type\":\"bytes16\"}],\"name\":\"setUploaderUuid\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUuidByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"},{\"name\":\"ownerUuid\",\"type\":\"bytes16\"},{\"name\":\"uploaderUuid\",\"type\":\"bytes16\"},{\"name\":\"fileType\",\"type\":\"bytes32\"},{\"name\":\"fileDesc\",\"type\":\"bytes32[4]\"},{\"name\":\"keccak256Hash\",\"type\":\"bytes32\"},{\"name\":\"sha256Hash\",\"type\":\"bytes32\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"addFile\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"isUuidExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"},{\"name\":\"fileDesc\",\"type\":\"bytes32[4]\"}],\"name\":\"setFileDesc\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getFileSignDataByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getSuperByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"delFile\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"},{\"name\":\"userUuid\",\"type\":\"bytes16\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"addSign\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"getSha256Hash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"getKeccak256Hash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"getFileType\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addSuper\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"getFileDesc\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[4]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sha256Hash\",\"type\":\"bytes32\"}],\"name\":\"getUuidBySha256Hash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"getTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"easyCnsAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"ownerUuid\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"uploaderUuid\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"fileType\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"fileDesc\",\"type\":\"bytes32[4]\"},{\"indexed\":false,\"name\":\"keccak256Hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sha256Hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"onAddFile\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"onDelFile\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"onSetActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"ownerUuid\",\"type\":\"bytes16\"}],\"name\":\"onSetOwnerUuid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"uploaderUuid\",\"type\":\"bytes16\"}],\"name\":\"onSetUploaderUuid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"fileType\",\"type\":\"bytes32\"}],\"name\":\"onSetFileType\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"fileDesc\",\"type\":\"bytes32[4]\"}],\"name\":\"onSetFileDesc\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"userUuid\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"onAddSign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"onSetTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"onAddFileStep0\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"onAddFileStep1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"onAddFileStep2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"onAddFileStep3\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"onAddFileStep4\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"onAddFileStep5\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"onAddFileStep6\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"onAddFileStep7\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"onAddFileStep8\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"onAddFileStep9\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"onAddFileStep10\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"onAddSuper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"onDelSuper\",\"type\":\"event\"}]"

// FilesDataBin is the compiled bytecode used for deploying new contracts.
const FilesDataBin = `606060405234156200000d57fe5b60405160208062005192833981016040528080519060200190919050505b5b33600060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b6200008d81620000e36401000000000262004a78176401000000009004565b15156200009a5760006000fd5b80600360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b5062000120565b6000600060008373ffffffffffffffffffffffffffffffffffffffff16141515156200010f5760006000fd5b823b90506000811191505b50919050565b61506280620001306000396000f30060606040523615610173576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306e4dffd1461017557806324716b55146101e257806328360cdd146102205780632f682a601461026057806334349621146102af57806338fc1214146102d55780633f7a52b61461034b5780635b379418146103875780635cbccaea146103f45780635d8de8b31461043b57806365f337f5146104995780636b303682146104cf5780636c75a331146104f55780637c333c0a14610544578063818030621461059e578063893d20e81461068b5780638eeded90146106dd578063a06f2e4614610728578063a8ecd64914610787578063ab013c26146107fb578063ab594cf61461085b578063af1e3afc1461088e578063b21124ef14610903578063c66a814514610952578063c8c459b9146109a1578063e1e8637b146109f0578063eedbe91514610a26578063fa04901f14610aa3578063fe07283a14610b01575bfe5b341561017d57fe5b6101a660048080356fffffffffffffffffffffffffffffffff1916906020019091905050610b48565b60405180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200191505060405180910390f35b34156101ea57fe5b61021e60048080356fffffffffffffffffffffffffffffffff19169060200190919080351515906020019091905050610c18565b005b341561022857fe5b61025e60048080356fffffffffffffffffffffffffffffffff191690602001909190803560001916906020019091905050610d48565b005b341561026857fe5b6102ad60048080356fffffffffffffffffffffffffffffffff19169060200190919080356fffffffffffffffffffffffffffffffff1916906020019091905050610f11565b005b34156102b757fe5b6102bf61123b565b6040518082815260200191505060405180910390f35b34156102dd57fe5b61030f60048080356fffffffffffffffffffffffffffffffff1916906020019091908035906020019091905050611249565b60405180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200191505060405180910390f35b341561035357fe5b61038560048080356fffffffffffffffffffffffffffffffff191690602001909190803590602001909190505061135c565b005b341561038f57fe5b6103b860048080356fffffffffffffffffffffffffffffffff19169060200190919050506114df565b60405180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200191505060405180910390f35b34156103fc57fe5b61042560048080356fffffffffffffffffffffffffffffffff19169060200190919050506115af565b6040518082815260200191505060405180910390f35b341561044357fe5b61045d600480803560001916906020019091905050611652565b60405180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200191505060405180910390f35b34156104a157fe5b6104cd600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050611739565b005b34156104d757fe5b6104df61194b565b6040518082815260200191505060405180910390f35b34156104fd57fe5b61054260048080356fffffffffffffffffffffffffffffffff19169060200190919080356fffffffffffffffffffffffffffffffff1916906020019091905050611959565b005b341561054c57fe5b6105626004808035906020019091905050611c83565b60405180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200191505060405180910390f35b34156105a657fe5b61068960048080356fffffffffffffffffffffffffffffffff19169060200190919080356fffffffffffffffffffffffffffffffff19169060200190919080356fffffffffffffffffffffffffffffffff19169060200190919080356000191690602001909190806080019060048060200260405190810160405280929190826004602002808284378201915050505050919080356000191690602001909190803560001916906020019091908035600019169060200190919080356000191690602001909190803560ff16906020019091908035906020019091905050611d08565b005b341561069357fe5b61069b612edc565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34156106e557fe5b61070e60048080356fffffffffffffffffffffffffffffffff1916906020019091905050612f07565b604051808215151515815260200191505060405180910390f35b341561073057fe5b61078560048080356fffffffffffffffffffffffffffffffff19169060200190919080608001906004806020026040519081016040528092919082600460200280828437820191505050505091905050612f6b565b005b341561078f57fe5b6107c160048080356fffffffffffffffffffffffffffffffff1916906020019091908035906020019091905050613155565b60405180846000191660001916815260200183600019166000191681526020018260ff1660ff168152602001935050505060405180910390f35b341561080357fe5b610819600480803590602001909190505061330e565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b341561086357fe5b61088c60048080356fffffffffffffffffffffffffffffffff1916906020019091905050613369565b005b341561089657fe5b61090160048080356fffffffffffffffffffffffffffffffff19169060200190919080356fffffffffffffffffffffffffffffffff1916906020019091908035600019169060200190919080356000191690602001909190803560ff169060200190919050506135d2565b005b341561090b57fe5b61093460048080356fffffffffffffffffffffffffffffffff1916906020019091905050613dbc565b60405180826000191660001916815260200191505060405180910390f35b341561095a57fe5b61098360048080356fffffffffffffffffffffffffffffffff1916906020019091905050613e5f565b60405180826000191660001916815260200191505060405180910390f35b34156109a957fe5b6109d260048080356fffffffffffffffffffffffffffffffff1916906020019091905050613f02565b60405180826000191660001916815260200191505060405180910390f35b34156109f857fe5b610a24600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050613fa5565b005b3415610a2e57fe5b610a5760048080356fffffffffffffffffffffffffffffffff1916906020019091905050614163565b6040518082600460200280838360008314610a91575b805182526020831115610a9157602082019150602081019050602083039250610a6d565b50505090500191505060405180910390f35b3415610aab57fe5b610ac5600480803560001916906020019091905050614298565b60405180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200191505060405180910390f35b3415610b0957fe5b610b3260048080356fffffffffffffffffffffffffffffffff191690602001909190505061437f565b6040518082815260200191505060405180910390f35b600060086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff161515610bb6576000700100000000000000000000000000000000029050610c13565b60086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060010160009054906101000a90047001000000000000000000000000000000000290505b919050565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480610c795750610c783361441f565b5b1515610c855760006000fd5b8060086000846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160006101000a81548160ff0219169083151502179055507f713e572bb47b301d3993c6d748aa8f43912b3e2864d1fd701e16e586fbb53905828260405180836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001821515151581526020019250505060405180910390a15b5b5050565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480610da95750610da83361441f565b5b1515610db55760006000fd5b8160086000826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff161515610e0c5760006000fd5b600070010000000000000000000000000000000002836fffffffffffffffffffffffffffffffff191614158015610e4b57506000600102826000191614155b1515610e575760006000fd5b8160086000856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060020181600019169055507f0f5d2a1fd7e620b5060ef0c66774a0475af737bef138fc169dfa8aca450e3899838360405180836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200182600019166000191681526020019250505060405180910390a15b5b505b5050565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480610f725750610f713361441f565b5b1515610f7e5760006000fd5b8160086000826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff161515610fd55760006000fd5b600070010000000000000000000000000000000002836fffffffffffffffffffffffffffffffff1916141580156110335750600070010000000000000000000000000000000002826fffffffffffffffffffffffffffffffff191614155b151561103f5760006000fd5b611047614499565b15156110535760006000fd5b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638eeded90836000604051602001526040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001915050602060405180830381600087803b151561110f57fe5b6102c65a03f1151561111d57fe5b5050506040518051905015156111335760006000fd5b8160086000856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160016101000a8154816fffffffffffffffffffffffffffffffff0219169083700100000000000000000000000000000000900402179055507f82e7473892dc1da52c17ad55ae9ce073d7e153c1313b43a75527e983c42f9c66838360405180836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019250505060405180910390a15b5b505b5050565b600060018054905090505b90565b600060086000846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff1680156112a2575060008210155b80156112b557506112b2836115af565b82105b1561133e5760086000846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600d018281548110151561130357fe5b90600052602060002090600291828204019190066010025b9054906101000a9004700100000000000000000000000000000000029050611356565b60007001000000000000000000000000000000000290505b92915050565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806113bd57506113bc3361441f565b5b15156113c95760006000fd5b8160086000826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff1615156114205760006000fd5b600082141515156114315760006000fd5b8160086000856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600901819055507f50843b091ea0bec4b6ead7f725b4fcb769671b6948c77b9cd98b25ff2440d84c838360405180836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020018281526020019250505060405180910390a15b5b505b5050565b600060086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff16151561154d5760007001000000000000000000000000000000000290506115aa565b60086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160019054906101000a90047001000000000000000000000000000000000290505b919050565b600060086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff16151561160a576000905061164d565b60086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600d018054905090505b919050565b60006008600060096000856000191660001916815260200190815260200160002060009054906101000a9004700100000000000000000000000000000000026fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff1615156116f8576000700100000000000000000000000000000000029050611734565b60096000836000191660001916815260200190815260200160002060009054906101000a90047001000000000000000000000000000000000290505b919050565b60006000600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561179a5760006000fd5b6117a38361441f565b15156117af5760006000fd5b60009150600090505b60018054905081101561184b576001818154811015156117d457fe5b906000526020600020900160005b9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141561183d576001915061184b565b5b80806001019150506117b8565b81151561185457fe5b60018181548110151561186357fe5b906000526020600020900160005b6101000a81549073ffffffffffffffffffffffffffffffffffffffff0219169055600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690557f5561c1cda602083d14af2f0773152f273f6f9bf8feb17ce6265f94aec25bde0083604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a15b5b505050565b6000600b8054905090505b90565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806119ba57506119b93361441f565b5b15156119c65760006000fd5b8160086000826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff161515611a1d5760006000fd5b600070010000000000000000000000000000000002836fffffffffffffffffffffffffffffffff191614158015611a7b5750600070010000000000000000000000000000000002826fffffffffffffffffffffffffffffffff191614155b1515611a875760006000fd5b611a8f614499565b1515611a9b5760006000fd5b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638eeded90836000604051602001526040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001915050602060405180830381600087803b1515611b5757fe5b6102c65a03f11515611b6557fe5b505050604051805190501515611b7b5760006000fd5b8160086000856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060010160006101000a8154816fffffffffffffffffffffffffffffffff0219169083700100000000000000000000000000000000900402179055507fd8aaf341152319250a5bbe3f879ed37a1710d2b5dfa9676f68e9bfb98e3de630838360405180836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019250505060405180910390a15b5b505b5050565b600060008210158015611c9c5750611c9961194b565b82105b15611ceb57600b82815481101515611cb057fe5b90600052602060002090600291828204019190066010025b9054906101000a9004700100000000000000000000000000000000029050611d03565b60007001000000000000000000000000000000000290505b919050565b611d10614af9565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611d715750611d703361441f565b5b1515611d7d5760006000fd5b8b60086000826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff16151515611dd55760006000fd5b7f4e256027454af3fd26f7e7a4b0750730b68989b274617b76483487b92d039f6d60405180905060405180910390a16000700100000000000000000000000000000000028d6fffffffffffffffffffffffffffffffff191614158015611e6257506000700100000000000000000000000000000000028c6fffffffffffffffffffffffffffffffff191614155b8015611e9557506000700100000000000000000000000000000000028b6fffffffffffffffffffffffffffffffff191614155b8015611ea9575060006001028a6000191614155b8015611ebd57506000600102886000191614155b8015611ed157506000600102876000191614155b8015611ee557506000600102866000191614155b8015611ef957506000600102856000191614155b8015611f06575060008314155b1515611f125760006000fd5b7fc9092c490974ca78edff24ade5ce5823286cf026469669fae88fdf1f7fc3107d60405180905060405180910390a1611f4a8d6146c2565b1515611f565760006000fd5b7f21cec0860cd4ae6e7e471e67e6c1aa086aff871e1f8b0cdbbf74422091aec59a60405180905060405180910390a1611f8e87614713565b1515611f9a5760006000fd5b7f401b65eb74bb9440b894a8c652928199f339b16dd0eb491c43b7221b54598ccf60405180905060405180910390a1611fd28861477f565b1515611fde5760006000fd5b7f7c6defcd62215168345bf11fbaf699551d6fece54ea6aeb1dbf22a9dd2e9bffb60405180905060405180910390a187600019168760001916141515156120255760006000fd5b7fa5774a70b1b4f1cc2714527a0f324a7f2162ad09def964bc5d6e84410414239c60405180905060405180910390a161205c614499565b15156120685760006000fd5b7f1c97ebd961ba4bbbf42bb3521f5daee73a4c427c662f74b7e5d6e826720d89dc60405180905060405180910390a1600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638eeded908d6000604051602001526040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001915050602060405180830381600087803b151561215357fe5b6102c65a03f1151561216157fe5b5050506040518051905015156121775760006000fd5b7f95e48219dccf7d1198e016684404154f0f96701dd80d95c9f3699e4235b9cbd260405180905060405180910390a1600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638eeded908c6000604051602001526040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001915050602060405180830381600087803b151561226257fe5b6102c65a03f1151561227057fe5b5050506040518051905015156122865760006000fd5b7f8bbe4c49460cf84693c316a80adb0bc97b4c8e5f2de3e0c8f8a18243c03446ea60405180905060405180910390a1600070010000000000000000000000000000000002600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663410f66e48d6000604051602001526040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001915050602060405180830381600087803b151561238657fe5b6102c65a03f1151561239457fe5b505050604051805190506fffffffffffffffffffffffffffffffff1916141515612580576123c06147eb565b15156123cc5760006000fd5b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638eeded90600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663410f66e48e6000604051602001526040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001915050602060405180830381600087803b15156124c657fe5b6102c65a03f115156124d457fe5b505050604051805190506000604051602001526040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001915050602060405180830381600087803b151561255b57fe5b6102c65a03f1151561256957fe5b50505060405180519050151561257f5760006000fd5b5b7f8239e34ad72fee63b4ead914623b739d0d8a030b0e0da2d87f05a939e0d6e58a60405180905060405180910390a1600188858888604051806000526020016040526000604051602001526040518085600019166000191681526020018460ff1660ff16815260200183600019166000191681526020018260001916600019168152602001945050505050602060405160208103908084039060008661646e5a03f1151561262a57fe5b50506020604051035173ffffffffffffffffffffffffffffffffffffffff16600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633d1ef2b78d6000604051602001526040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001915050602060405180830381600087803b151561270557fe5b6102c65a03f1151561271357fe5b5050506040518051905073ffffffffffffffffffffffffffffffffffffffff161415156127405760006000fd5b7f20fed4367af743411a2085709baea3083d7b76275447358cf5fe0c92a70df37d60405180905060405180910390a160018260000190151590811515815250508b82602001906fffffffffffffffffffffffffffffffff191690816fffffffffffffffffffffffffffffffff1916815250508a82604001906fffffffffffffffffffffffffffffffff191690816fffffffffffffffffffffffffffffffff1916815250508982606001906000191690816000191681525050888260800181905250878260a001906000191690816000191681525050868260c001906000191690816000191681525050828260e001818152505081600860008f6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060008201518160000160006101000a81548160ff02191690831515021790555060208201518160000160016101000a8154816fffffffffffffffffffffffffffffffff02191690837001000000000000000000000000000000009004021790555060408201518160010160006101000a8154816fffffffffffffffffffffffffffffffff02191690837001000000000000000000000000000000009004021790555060608201518160020190600019169055608082015181600301906004612936929190614bad565b5060a0820151816007019060001916905560c0820151816008019060001916905560e0820151816009015561010082015181600a01908051906020019061297e929190614bf3565b5061012082015181600b01908051906020019061299c929190614bf3565b5061014082015181600c0190805190602001906129ba929190614c46565b5061016082015181600d0190805190602001906129d8929190614ced565b50905050600860008e6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600a018054806001018281612a2a9190614dc3565b916000526020600020900160005b8890919091509060001916905550600860008e6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600b018054806001018281612a949190614dc3565b916000526020600020900160005b8790919091509060001916905550600860008e6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600c018054806001018281612afe9190614def565b91600052602060002090602091828204019190065b86909190916101000a81548160ff021916908360ff16021790555050600860008e6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600d018054806001018281612b7d9190614e29565b91600052602060002090600291828204019190066010025b8d909190916101000a8154816fffffffffffffffffffffffffffffffff021916908370010000000000000000000000000000000090040217905550506001600860008f6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600e0160008d6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff0219169083151502179055508c600960008a6000191660001916815260200190815260200160002060006101000a8154816fffffffffffffffffffffffffffffffff0219169083700100000000000000000000000000000000900402179055508c600a6000896000191660001916815260200190815260200160002060006101000a8154816fffffffffffffffffffffffffffffffff021916908370010000000000000000000000000000000090040217905550600b8054806001018281612d199190614e29565b91600052602060002090600291828204019190066010025b8f909190916101000a8154816fffffffffffffffffffffffffffffffff021916908370010000000000000000000000000000000090040217905550507fe5db0782a88ef1dd5e05dbcd66036151fdd928c04a041691230dff05e269440a8d8d8d8d8d8d8d8d8d8d8d604051808c6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020018b6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020018a6fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001896000191660001916815260200188600460200280838360008314612e65575b805182526020831115612e6557602082019150602081019050602083039250612e41565b50505090500187600019166000191681526020018660001916600019168152602001856000191660001916815260200184600019166000191681526020018360ff1660ff1681526020018281526020019b50505050505050505050505060405180910390a15b5b505b505050505050505050505050565b6000600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690505b90565b600060086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff1615612f615760019050612f66565b600090505b919050565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480612fcc5750612fcb3361441f565b5b1515612fd85760006000fd5b8160086000826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff16151561302f5760006000fd5b600070010000000000000000000000000000000002836fffffffffffffffffffffffffffffffff1916141515156130665760006000fd5b8160086000856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020016000206003019060046130b1929190614e63565b507f62c9cfebd42861a16451b2ce63bf3d3e5bcdb62acbc46482d52d0c48d34eb9b3838360405180836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020018260046020028083836000831461313b575b80518252602083111561313b57602082019150602081019050602083039250613117565b5050509050019250505060405180910390a15b5b505b5050565b60006000600060086000866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff1680156131b2575060008410155b80156131c557506131c2856115af565b84105b156132f15760086000866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600a018481548110151561321357fe5b906000526020600020900160005b505460086000876fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600b018581548110151561326c57fe5b906000526020600020900160005b505460086000886fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600c01868154811015156132c557fe5b90600052602060002090602091828204019190065b9054906101000a900460ff16925092509250613307565b6000600102600060010260008090509250925092505b9250925092565b600061331982614a14565b15156133255760006000fd5b60018281548110151561333457fe5b906000526020600020900160005b9054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690505b919050565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806133ca57506133c93361441f565b5b15156133d65760006000fd5b8060086000826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff16151561342d5760006000fd5b6009600060086000856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600701546000191660001916815260200190815260200160002060006101000a8154906fffffffffffffffffffffffffffffffff0219169055600a600060086000856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600801546000191660001916815260200190815260200160002060006101000a8154906fffffffffffffffffffffffffffffffff0219169055600060086000846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160006101000a81548160ff0219169083151502179055507f5084265f9b0b758e57a9c7d957106776471ed835d7267fb54d933927a3481bfd8260405180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200191505060405180910390a15b5b505b50565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061363357506136323361441f565b5b151561363f5760006000fd5b8460086000826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff1615156136965760006000fd5b600070010000000000000000000000000000000002866fffffffffffffffffffffffffffffffff1916141580156136f45750600070010000000000000000000000000000000002856fffffffffffffffffffffffffffffffff191614155b801561370857506000600102846000191614155b801561371c57506000600102836000191614155b15156137285760006000fd5b60086000876fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600e016000866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060009054906101000a900460ff161515156137b65760006000fd5b6137be614499565b15156137ca5760006000fd5b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16638eeded90866000604051602001526040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001915050602060405180830381600087803b151561388657fe5b6102c65a03f1151561389457fe5b5050506040518051905015156138aa5760006000fd5b600160086000886fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060070154838686604051806000526020016040526000604051602001526040518085600019166000191681526020018460ff1660ff16815260200183600019166000191681526020018260001916600019168152602001945050505050602060405160208103908084039060008661646e5a03f1151561396157fe5b50506020604051035173ffffffffffffffffffffffffffffffffffffffff16600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16633d1ef2b7876000604051602001526040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180826fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001915050602060405180830381600087803b1515613a3c57fe5b6102c65a03f11515613a4a57fe5b5050506040518051905073ffffffffffffffffffffffffffffffffffffffff16141515613a775760006000fd5b60086000876fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600a018054806001018281613ac59190614dc3565b916000526020600020900160005b869091909150906000191690555060086000876fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600b018054806001018281613b2f9190614dc3565b916000526020600020900160005b859091909150906000191690555060086000876fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600c018054806001018281613b999190614def565b91600052602060002090602091828204019190065b84909190916101000a81548160ff021916908360ff1602179055505060086000876fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600d018054806001018281613c189190614e29565b91600052602060002090600291828204019190066010025b87909190916101000a8154816fffffffffffffffffffffffffffffffff02191690837001000000000000000000000000000000009004021790555050600160086000886fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001908152602001600020600e016000876fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548160ff0219169083151502179055507fb6d8f3f2b7e44359d0f3577f248b9a9b8e6c275f3c9b6752d9c6905a0d18a2ac868686868660405180866fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001856fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff19168152602001846000191660001916815260200183600019166000191681526020018260ff1660ff1681526020019550505050505060405180910390a15b5b505b5050505050565b600060086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff161515613e1a5760006001029050613e5a565b60086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020016000206008015490505b919050565b600060086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff161515613ebd5760006001029050613efd565b60086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020016000206007015490505b919050565b600060086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff161515613f605760006001029050613fa0565b60086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020016000206002015490505b919050565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156140025760006000fd5b60008173ffffffffffffffffffffffffffffffffffffffff16141515156140295760006000fd5b6140328161441f565b15151561403f5760006000fd5b600180548060010182816140539190614ea9565b916000526020600020900160005b83909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506001600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055507f920999c03a7fd19172e4c657c22aa62a1bfb5e027a8cf6a2a0ee9daf4c5a347481604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a15b5b50565b61416b614ed5565b60086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff16151561421457608060405190810160405280600060010260001916600019168152602001600060010260001916600019168152602001600060010260001916600019168152602001600060010260001916600019168152509050614293565b60086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060030160048060200260405190810160405280929190826004801561428b576020028201915b81546000191681526020019060010190808311614273575b505050505090505b919050565b600060086000600a6000856000191660001916815260200190815260200160002060009054906101000a9004700100000000000000000000000000000000026fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff16151561433e57600070010000000000000000000000000000000002905061437a565b600a6000836000191660001916815260200190815260200160002060009054906101000a90047001000000000000000000000000000000000290505b919050565b600060086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060000160009054906101000a900460ff1615156143da576000905061441a565b60086000836fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff191681526020019081526020016000206009015490505b919050565b600060008273ffffffffffffffffffffffffffffffffffffffff16141580156144915750600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b90505b919050565b60006000600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663693ec85e6144e3614a33565b6000604051602001526040518263ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018080602001828103825283818151815260200191508051906020019080838360008314614566575b80518252602083111561456657602082019150602081019050602083039250614542565b505050905090810190601f1680156145925780820380516001836020036101000a031916815260200191505b5092505050602060405180830381600087803b15156145ad57fe5b6102c65a03f115156145bb57fe5b5050506040518051905090506145d081614a78565b15156145df57600091506146be565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415156146b95780600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b600191505b5090565b6000600060010260086000846fffffffffffffffffffffffffffffffff19166fffffffffffffffffffffffffffffffff1916815260200190815260200160002060070154600019161490505b919050565b6000600070010000000000000000000000000000000002600a6000846000191660001916815260200190815260200160002060009054906101000a9004700100000000000000000000000000000000026fffffffffffffffffffffffffffffffff19161490505b919050565b600060007001000000000000000000000000000000000260096000846000191660001916815260200190815260200160002060009054906101000a9004700100000000000000000000000000000000026fffffffffffffffffffffffffffffffff19161490505b919050565b60006000600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663693ec85e614835614ab4565b6000604051602001526040518263ffffffff167c010000000000000000000000000000000000000000000000000000000002815260040180806020018281038252838181518152602001915080519060200190808383600083146148b8575b8051825260208311156148b857602082019150602081019050602083039250614894565b505050905090810190601f1680156148e45780820380516001836020036101000a031916815260200191505b5092505050602060405180830381600087803b15156148ff57fe5b6102c65a03f1151561490d57fe5b50505060405180519050905061492281614a78565b15156149315760009150614a10565b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141515614a0b5780600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b600191505b5090565b600060008210158015614a2b575060018054905082105b90505b919050565b614a3b614f01565b604060405190810160405280600981526020017f557365727344617461000000000000000000000000000000000000000000000081525090505b90565b6000600060008373ffffffffffffffffffffffffffffffffffffffff1614151515614aa35760006000fd5b823b90506000811191505b50919050565b614abc614f01565b604060405190810160405280600881526020017f4f7267734461746100000000000000000000000000000000000000000000000081525090505b90565b6101e06040519081016040528060001515815260200160006fffffffffffffffffffffffffffffffff1916815260200160006fffffffffffffffffffffffffffffffff191681526020016000600019168152602001614b56614f15565b81526020016000600019168152602001600060001916815260200160008152602001614b80614f41565b8152602001614b8d614f41565b8152602001614b9a614f55565b8152602001614ba7614f69565b81525090565b8260048101928215614be2579160200282015b82811115614be1578251829060001916905591602001919060010190614bc0565b5b509050614bef9190614f7d565b5090565b828054828255906000526020600020908101928215614c35579160200282015b82811115614c34578251829060001916905591602001919060010190614c13565b5b509050614c429190614f7d565b5090565b82805482825590600052602060002090601f01602090048101928215614cdc5791602002820160005b83821115614cad57835183826101000a81548160ff021916908360ff1602179055509260200192600101602081600001049283019260010302614c6f565b8015614cda5782816101000a81549060ff0219169055600101602081600001049283019260010302614cad565b505b509050614ce99190614fa2565b5090565b82805482825590600052602060002090600101600290048101928215614db25791602002820160005b83821115614d7457835183826101000a8154816fffffffffffffffffffffffffffffffff0219169083700100000000000000000000000000000000900402179055509260200192601001602081600f01049283019260010302614d16565b8015614db05782816101000a8154906fffffffffffffffffffffffffffffffff0219169055601001602081600f01049283019260010302614d74565b505b509050614dbf9190614fd2565b5090565b815481835581811511614dea57818360005260206000209182019101614de99190614f7d565b5b505050565b815481835581811511614e2457601f016020900481601f01602090048360005260206000209182019101614e239190615011565b5b505050565b815481835581811511614e5e576001016002900481600101600290048360005260206000209182019101614e5d9190615011565b5b505050565b8260048101928215614e98579160200282015b82811115614e97578251829060001916905591602001919060010190614e76565b5b509050614ea59190614f7d565b5090565b815481835581811511614ed057818360005260206000209182019101614ecf9190615011565b5b505050565b6080604051908101604052806004905b600060001916815260200190600190039081614ee55790505090565b602060405190810160405280600081525090565b6080604051908101604052806004905b600060001916815260200190600190039081614f255790505090565b602060405190810160405280600081525090565b602060405190810160405280600081525090565b602060405190810160405280600081525090565b614f9f91905b80821115614f9b576000816000905550600101614f83565b5090565b90565b614fcf91905b80821115614fcb57600081816101000a81549060ff021916905550600101614fa8565b5090565b90565b61500e91905b8082111561500a57600081816101000a8154906fffffffffffffffffffffffffffffffff021916905550600101614fd8565b5090565b90565b61503391905b8082111561502f576000816000905550600101615017565b5090565b905600a165627a7a723058207de9299d75d5fd700ea26b1193bde6bf2a5e45af4eed9d27565d4e48d4aca6290029`

// DeployFilesData deploys a new Ethereum contract, binding an instance of FilesData to it.
func DeployFilesData(auth *bind.TransactOpts, backend bind.ContractBackend, easyCnsAddress common.Address) (common.Address, *types.Transaction, *FilesData, error) {
	parsed, err := abi.JSON(strings.NewReader(FilesDataABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(FilesDataBin), backend, easyCnsAddress)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &FilesData{FilesDataCaller: FilesDataCaller{contract: contract}, FilesDataTransactor: FilesDataTransactor{contract: contract}, FilesDataFilterer: FilesDataFilterer{contract: contract}}, nil
}

// FilesData is an auto generated Go binding around an Ethereum contract.
type FilesData struct {
	FilesDataCaller     // Read-only binding to the contract
	FilesDataTransactor // Write-only binding to the contract
	FilesDataFilterer   // Log filterer for contract events
}

// FilesDataCaller is an auto generated read-only Go binding around an Ethereum contract.
type FilesDataCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FilesDataTransactor is an auto generated write-only Go binding around an Ethereum contract.
type FilesDataTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FilesDataFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type FilesDataFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// FilesDataSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type FilesDataSession struct {
	Contract     *FilesData        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// FilesDataCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type FilesDataCallerSession struct {
	Contract *FilesDataCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// FilesDataTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type FilesDataTransactorSession struct {
	Contract     *FilesDataTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// FilesDataRaw is an auto generated low-level Go binding around an Ethereum contract.
type FilesDataRaw struct {
	Contract *FilesData // Generic contract binding to access the raw methods on
}

// FilesDataCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type FilesDataCallerRaw struct {
	Contract *FilesDataCaller // Generic read-only contract binding to access the raw methods on
}

// FilesDataTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type FilesDataTransactorRaw struct {
	Contract *FilesDataTransactor // Generic write-only contract binding to access the raw methods on
}

// NewFilesData creates a new instance of FilesData, bound to a specific deployed contract.
func NewFilesData(address common.Address, backend bind.ContractBackend) (*FilesData, error) {
	contract, err := bindFilesData(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &FilesData{FilesDataCaller: FilesDataCaller{contract: contract}, FilesDataTransactor: FilesDataTransactor{contract: contract}, FilesDataFilterer: FilesDataFilterer{contract: contract}}, nil
}

// NewFilesDataCaller creates a new read-only instance of FilesData, bound to a specific deployed contract.
func NewFilesDataCaller(address common.Address, caller bind.ContractCaller) (*FilesDataCaller, error) {
	contract, err := bindFilesData(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &FilesDataCaller{contract: contract}, nil
}

// NewFilesDataTransactor creates a new write-only instance of FilesData, bound to a specific deployed contract.
func NewFilesDataTransactor(address common.Address, transactor bind.ContractTransactor) (*FilesDataTransactor, error) {
	contract, err := bindFilesData(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &FilesDataTransactor{contract: contract}, nil
}

// NewFilesDataFilterer creates a new log filterer instance of FilesData, bound to a specific deployed contract.
func NewFilesDataFilterer(address common.Address, filterer bind.ContractFilterer) (*FilesDataFilterer, error) {
	contract, err := bindFilesData(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &FilesDataFilterer{contract: contract}, nil
}

// bindFilesData binds a generic wrapper to an already deployed contract.
func bindFilesData(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(FilesDataABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FilesData *FilesDataRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _FilesData.Contract.FilesDataCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FilesData *FilesDataRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FilesData.Contract.FilesDataTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FilesData *FilesDataRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FilesData.Contract.FilesDataTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_FilesData *FilesDataCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _FilesData.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_FilesData *FilesDataTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _FilesData.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_FilesData *FilesDataTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _FilesData.Contract.contract.Transact(opts, method, params...)
}

// GetFileDesc is a free data retrieval call binding the contract method 0xeedbe915.
//
// Solidity: function getFileDesc(uuid bytes16) constant returns(bytes32[4])
func (_FilesData *FilesDataCaller) GetFileDesc(opts *bind.CallOpts, uuid [16]byte) ([4][32]byte, error) {
	var (
		ret0 = new([4][32]byte)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getFileDesc", uuid)
	return *ret0, err
}

// GetFileDesc is a free data retrieval call binding the contract method 0xeedbe915.
//
// Solidity: function getFileDesc(uuid bytes16) constant returns(bytes32[4])
func (_FilesData *FilesDataSession) GetFileDesc(uuid [16]byte) ([4][32]byte, error) {
	return _FilesData.Contract.GetFileDesc(&_FilesData.CallOpts, uuid)
}

// GetFileDesc is a free data retrieval call binding the contract method 0xeedbe915.
//
// Solidity: function getFileDesc(uuid bytes16) constant returns(bytes32[4])
func (_FilesData *FilesDataCallerSession) GetFileDesc(uuid [16]byte) ([4][32]byte, error) {
	return _FilesData.Contract.GetFileDesc(&_FilesData.CallOpts, uuid)
}

// GetFileSignDataByIndex is a free data retrieval call binding the contract method 0xa8ecd649.
//
// Solidity: function getFileSignDataByIndex(uuid bytes16, index uint256) constant returns(bytes32, bytes32, uint8)
func (_FilesData *FilesDataCaller) GetFileSignDataByIndex(opts *bind.CallOpts, uuid [16]byte, index *big.Int) ([32]byte, [32]byte, uint8, error) {
	var (
		ret0 = new([32]byte)
		ret1 = new([32]byte)
		ret2 = new(uint8)
	)
	out := &[]interface{}{
		ret0,
		ret1,
		ret2,
	}
	err := _FilesData.contract.Call(opts, out, "getFileSignDataByIndex", uuid, index)
	return *ret0, *ret1, *ret2, err
}

// GetFileSignDataByIndex is a free data retrieval call binding the contract method 0xa8ecd649.
//
// Solidity: function getFileSignDataByIndex(uuid bytes16, index uint256) constant returns(bytes32, bytes32, uint8)
func (_FilesData *FilesDataSession) GetFileSignDataByIndex(uuid [16]byte, index *big.Int) ([32]byte, [32]byte, uint8, error) {
	return _FilesData.Contract.GetFileSignDataByIndex(&_FilesData.CallOpts, uuid, index)
}

// GetFileSignDataByIndex is a free data retrieval call binding the contract method 0xa8ecd649.
//
// Solidity: function getFileSignDataByIndex(uuid bytes16, index uint256) constant returns(bytes32, bytes32, uint8)
func (_FilesData *FilesDataCallerSession) GetFileSignDataByIndex(uuid [16]byte, index *big.Int) ([32]byte, [32]byte, uint8, error) {
	return _FilesData.Contract.GetFileSignDataByIndex(&_FilesData.CallOpts, uuid, index)
}

// GetFileSignerSize is a free data retrieval call binding the contract method 0x5cbccaea.
//
// Solidity: function getFileSignerSize(uuid bytes16) constant returns(uint256)
func (_FilesData *FilesDataCaller) GetFileSignerSize(opts *bind.CallOpts, uuid [16]byte) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getFileSignerSize", uuid)
	return *ret0, err
}

// GetFileSignerSize is a free data retrieval call binding the contract method 0x5cbccaea.
//
// Solidity: function getFileSignerSize(uuid bytes16) constant returns(uint256)
func (_FilesData *FilesDataSession) GetFileSignerSize(uuid [16]byte) (*big.Int, error) {
	return _FilesData.Contract.GetFileSignerSize(&_FilesData.CallOpts, uuid)
}

// GetFileSignerSize is a free data retrieval call binding the contract method 0x5cbccaea.
//
// Solidity: function getFileSignerSize(uuid bytes16) constant returns(uint256)
func (_FilesData *FilesDataCallerSession) GetFileSignerSize(uuid [16]byte) (*big.Int, error) {
	return _FilesData.Contract.GetFileSignerSize(&_FilesData.CallOpts, uuid)
}

// GetFileSignerUuidByIndex is a free data retrieval call binding the contract method 0x38fc1214.
//
// Solidity: function getFileSignerUuidByIndex(uuid bytes16, index uint256) constant returns(bytes16)
func (_FilesData *FilesDataCaller) GetFileSignerUuidByIndex(opts *bind.CallOpts, uuid [16]byte, index *big.Int) ([16]byte, error) {
	var (
		ret0 = new([16]byte)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getFileSignerUuidByIndex", uuid, index)
	return *ret0, err
}

// GetFileSignerUuidByIndex is a free data retrieval call binding the contract method 0x38fc1214.
//
// Solidity: function getFileSignerUuidByIndex(uuid bytes16, index uint256) constant returns(bytes16)
func (_FilesData *FilesDataSession) GetFileSignerUuidByIndex(uuid [16]byte, index *big.Int) ([16]byte, error) {
	return _FilesData.Contract.GetFileSignerUuidByIndex(&_FilesData.CallOpts, uuid, index)
}

// GetFileSignerUuidByIndex is a free data retrieval call binding the contract method 0x38fc1214.
//
// Solidity: function getFileSignerUuidByIndex(uuid bytes16, index uint256) constant returns(bytes16)
func (_FilesData *FilesDataCallerSession) GetFileSignerUuidByIndex(uuid [16]byte, index *big.Int) ([16]byte, error) {
	return _FilesData.Contract.GetFileSignerUuidByIndex(&_FilesData.CallOpts, uuid, index)
}

// GetFileType is a free data retrieval call binding the contract method 0xc8c459b9.
//
// Solidity: function getFileType(uuid bytes16) constant returns(bytes32)
func (_FilesData *FilesDataCaller) GetFileType(opts *bind.CallOpts, uuid [16]byte) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getFileType", uuid)
	return *ret0, err
}

// GetFileType is a free data retrieval call binding the contract method 0xc8c459b9.
//
// Solidity: function getFileType(uuid bytes16) constant returns(bytes32)
func (_FilesData *FilesDataSession) GetFileType(uuid [16]byte) ([32]byte, error) {
	return _FilesData.Contract.GetFileType(&_FilesData.CallOpts, uuid)
}

// GetFileType is a free data retrieval call binding the contract method 0xc8c459b9.
//
// Solidity: function getFileType(uuid bytes16) constant returns(bytes32)
func (_FilesData *FilesDataCallerSession) GetFileType(uuid [16]byte) ([32]byte, error) {
	return _FilesData.Contract.GetFileType(&_FilesData.CallOpts, uuid)
}

// GetKeccak256Hash is a free data retrieval call binding the contract method 0xc66a8145.
//
// Solidity: function getKeccak256Hash(uuid bytes16) constant returns(bytes32)
func (_FilesData *FilesDataCaller) GetKeccak256Hash(opts *bind.CallOpts, uuid [16]byte) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getKeccak256Hash", uuid)
	return *ret0, err
}

// GetKeccak256Hash is a free data retrieval call binding the contract method 0xc66a8145.
//
// Solidity: function getKeccak256Hash(uuid bytes16) constant returns(bytes32)
func (_FilesData *FilesDataSession) GetKeccak256Hash(uuid [16]byte) ([32]byte, error) {
	return _FilesData.Contract.GetKeccak256Hash(&_FilesData.CallOpts, uuid)
}

// GetKeccak256Hash is a free data retrieval call binding the contract method 0xc66a8145.
//
// Solidity: function getKeccak256Hash(uuid bytes16) constant returns(bytes32)
func (_FilesData *FilesDataCallerSession) GetKeccak256Hash(uuid [16]byte) ([32]byte, error) {
	return _FilesData.Contract.GetKeccak256Hash(&_FilesData.CallOpts, uuid)
}

// GetOwner is a free data retrieval call binding the contract method 0x893d20e8.
//
// Solidity: function getOwner() constant returns(address)
func (_FilesData *FilesDataCaller) GetOwner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getOwner")
	return *ret0, err
}

// GetOwner is a free data retrieval call binding the contract method 0x893d20e8.
//
// Solidity: function getOwner() constant returns(address)
func (_FilesData *FilesDataSession) GetOwner() (common.Address, error) {
	return _FilesData.Contract.GetOwner(&_FilesData.CallOpts)
}

// GetOwner is a free data retrieval call binding the contract method 0x893d20e8.
//
// Solidity: function getOwner() constant returns(address)
func (_FilesData *FilesDataCallerSession) GetOwner() (common.Address, error) {
	return _FilesData.Contract.GetOwner(&_FilesData.CallOpts)
}

// GetOwnerUuid is a free data retrieval call binding the contract method 0x5b379418.
//
// Solidity: function getOwnerUuid(uuid bytes16) constant returns(bytes16)
func (_FilesData *FilesDataCaller) GetOwnerUuid(opts *bind.CallOpts, uuid [16]byte) ([16]byte, error) {
	var (
		ret0 = new([16]byte)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getOwnerUuid", uuid)
	return *ret0, err
}

// GetOwnerUuid is a free data retrieval call binding the contract method 0x5b379418.
//
// Solidity: function getOwnerUuid(uuid bytes16) constant returns(bytes16)
func (_FilesData *FilesDataSession) GetOwnerUuid(uuid [16]byte) ([16]byte, error) {
	return _FilesData.Contract.GetOwnerUuid(&_FilesData.CallOpts, uuid)
}

// GetOwnerUuid is a free data retrieval call binding the contract method 0x5b379418.
//
// Solidity: function getOwnerUuid(uuid bytes16) constant returns(bytes16)
func (_FilesData *FilesDataCallerSession) GetOwnerUuid(uuid [16]byte) ([16]byte, error) {
	return _FilesData.Contract.GetOwnerUuid(&_FilesData.CallOpts, uuid)
}

// GetSha256Hash is a free data retrieval call binding the contract method 0xb21124ef.
//
// Solidity: function getSha256Hash(uuid bytes16) constant returns(bytes32)
func (_FilesData *FilesDataCaller) GetSha256Hash(opts *bind.CallOpts, uuid [16]byte) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getSha256Hash", uuid)
	return *ret0, err
}

// GetSha256Hash is a free data retrieval call binding the contract method 0xb21124ef.
//
// Solidity: function getSha256Hash(uuid bytes16) constant returns(bytes32)
func (_FilesData *FilesDataSession) GetSha256Hash(uuid [16]byte) ([32]byte, error) {
	return _FilesData.Contract.GetSha256Hash(&_FilesData.CallOpts, uuid)
}

// GetSha256Hash is a free data retrieval call binding the contract method 0xb21124ef.
//
// Solidity: function getSha256Hash(uuid bytes16) constant returns(bytes32)
func (_FilesData *FilesDataCallerSession) GetSha256Hash(uuid [16]byte) ([32]byte, error) {
	return _FilesData.Contract.GetSha256Hash(&_FilesData.CallOpts, uuid)
}

// GetSuperByIndex is a free data retrieval call binding the contract method 0xab013c26.
//
// Solidity: function getSuperByIndex(index uint256) constant returns(address)
func (_FilesData *FilesDataCaller) GetSuperByIndex(opts *bind.CallOpts, index *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getSuperByIndex", index)
	return *ret0, err
}

// GetSuperByIndex is a free data retrieval call binding the contract method 0xab013c26.
//
// Solidity: function getSuperByIndex(index uint256) constant returns(address)
func (_FilesData *FilesDataSession) GetSuperByIndex(index *big.Int) (common.Address, error) {
	return _FilesData.Contract.GetSuperByIndex(&_FilesData.CallOpts, index)
}

// GetSuperByIndex is a free data retrieval call binding the contract method 0xab013c26.
//
// Solidity: function getSuperByIndex(index uint256) constant returns(address)
func (_FilesData *FilesDataCallerSession) GetSuperByIndex(index *big.Int) (common.Address, error) {
	return _FilesData.Contract.GetSuperByIndex(&_FilesData.CallOpts, index)
}

// GetSuperSize is a free data retrieval call binding the contract method 0x34349621.
//
// Solidity: function getSuperSize() constant returns(uint256)
func (_FilesData *FilesDataCaller) GetSuperSize(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getSuperSize")
	return *ret0, err
}

// GetSuperSize is a free data retrieval call binding the contract method 0x34349621.
//
// Solidity: function getSuperSize() constant returns(uint256)
func (_FilesData *FilesDataSession) GetSuperSize() (*big.Int, error) {
	return _FilesData.Contract.GetSuperSize(&_FilesData.CallOpts)
}

// GetSuperSize is a free data retrieval call binding the contract method 0x34349621.
//
// Solidity: function getSuperSize() constant returns(uint256)
func (_FilesData *FilesDataCallerSession) GetSuperSize() (*big.Int, error) {
	return _FilesData.Contract.GetSuperSize(&_FilesData.CallOpts)
}

// GetTime is a free data retrieval call binding the contract method 0xfe07283a.
//
// Solidity: function getTime(uuid bytes16) constant returns(uint256)
func (_FilesData *FilesDataCaller) GetTime(opts *bind.CallOpts, uuid [16]byte) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getTime", uuid)
	return *ret0, err
}

// GetTime is a free data retrieval call binding the contract method 0xfe07283a.
//
// Solidity: function getTime(uuid bytes16) constant returns(uint256)
func (_FilesData *FilesDataSession) GetTime(uuid [16]byte) (*big.Int, error) {
	return _FilesData.Contract.GetTime(&_FilesData.CallOpts, uuid)
}

// GetTime is a free data retrieval call binding the contract method 0xfe07283a.
//
// Solidity: function getTime(uuid bytes16) constant returns(uint256)
func (_FilesData *FilesDataCallerSession) GetTime(uuid [16]byte) (*big.Int, error) {
	return _FilesData.Contract.GetTime(&_FilesData.CallOpts, uuid)
}

// GetUploaderUuid is a free data retrieval call binding the contract method 0x06e4dffd.
//
// Solidity: function getUploaderUuid(uuid bytes16) constant returns(bytes16)
func (_FilesData *FilesDataCaller) GetUploaderUuid(opts *bind.CallOpts, uuid [16]byte) ([16]byte, error) {
	var (
		ret0 = new([16]byte)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getUploaderUuid", uuid)
	return *ret0, err
}

// GetUploaderUuid is a free data retrieval call binding the contract method 0x06e4dffd.
//
// Solidity: function getUploaderUuid(uuid bytes16) constant returns(bytes16)
func (_FilesData *FilesDataSession) GetUploaderUuid(uuid [16]byte) ([16]byte, error) {
	return _FilesData.Contract.GetUploaderUuid(&_FilesData.CallOpts, uuid)
}

// GetUploaderUuid is a free data retrieval call binding the contract method 0x06e4dffd.
//
// Solidity: function getUploaderUuid(uuid bytes16) constant returns(bytes16)
func (_FilesData *FilesDataCallerSession) GetUploaderUuid(uuid [16]byte) ([16]byte, error) {
	return _FilesData.Contract.GetUploaderUuid(&_FilesData.CallOpts, uuid)
}

// GetUuidByIndex is a free data retrieval call binding the contract method 0x7c333c0a.
//
// Solidity: function getUuidByIndex(index uint256) constant returns(bytes16)
func (_FilesData *FilesDataCaller) GetUuidByIndex(opts *bind.CallOpts, index *big.Int) ([16]byte, error) {
	var (
		ret0 = new([16]byte)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getUuidByIndex", index)
	return *ret0, err
}

// GetUuidByIndex is a free data retrieval call binding the contract method 0x7c333c0a.
//
// Solidity: function getUuidByIndex(index uint256) constant returns(bytes16)
func (_FilesData *FilesDataSession) GetUuidByIndex(index *big.Int) ([16]byte, error) {
	return _FilesData.Contract.GetUuidByIndex(&_FilesData.CallOpts, index)
}

// GetUuidByIndex is a free data retrieval call binding the contract method 0x7c333c0a.
//
// Solidity: function getUuidByIndex(index uint256) constant returns(bytes16)
func (_FilesData *FilesDataCallerSession) GetUuidByIndex(index *big.Int) ([16]byte, error) {
	return _FilesData.Contract.GetUuidByIndex(&_FilesData.CallOpts, index)
}

// GetUuidByKeccak256Hash is a free data retrieval call binding the contract method 0x5d8de8b3.
//
// Solidity: function getUuidByKeccak256Hash(keccak256Hash bytes32) constant returns(bytes16)
func (_FilesData *FilesDataCaller) GetUuidByKeccak256Hash(opts *bind.CallOpts, keccak256Hash [32]byte) ([16]byte, error) {
	var (
		ret0 = new([16]byte)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getUuidByKeccak256Hash", keccak256Hash)
	return *ret0, err
}

// GetUuidByKeccak256Hash is a free data retrieval call binding the contract method 0x5d8de8b3.
//
// Solidity: function getUuidByKeccak256Hash(keccak256Hash bytes32) constant returns(bytes16)
func (_FilesData *FilesDataSession) GetUuidByKeccak256Hash(keccak256Hash [32]byte) ([16]byte, error) {
	return _FilesData.Contract.GetUuidByKeccak256Hash(&_FilesData.CallOpts, keccak256Hash)
}

// GetUuidByKeccak256Hash is a free data retrieval call binding the contract method 0x5d8de8b3.
//
// Solidity: function getUuidByKeccak256Hash(keccak256Hash bytes32) constant returns(bytes16)
func (_FilesData *FilesDataCallerSession) GetUuidByKeccak256Hash(keccak256Hash [32]byte) ([16]byte, error) {
	return _FilesData.Contract.GetUuidByKeccak256Hash(&_FilesData.CallOpts, keccak256Hash)
}

// GetUuidBySha256Hash is a free data retrieval call binding the contract method 0xfa04901f.
//
// Solidity: function getUuidBySha256Hash(sha256Hash bytes32) constant returns(bytes16)
func (_FilesData *FilesDataCaller) GetUuidBySha256Hash(opts *bind.CallOpts, sha256Hash [32]byte) ([16]byte, error) {
	var (
		ret0 = new([16]byte)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getUuidBySha256Hash", sha256Hash)
	return *ret0, err
}

// GetUuidBySha256Hash is a free data retrieval call binding the contract method 0xfa04901f.
//
// Solidity: function getUuidBySha256Hash(sha256Hash bytes32) constant returns(bytes16)
func (_FilesData *FilesDataSession) GetUuidBySha256Hash(sha256Hash [32]byte) ([16]byte, error) {
	return _FilesData.Contract.GetUuidBySha256Hash(&_FilesData.CallOpts, sha256Hash)
}

// GetUuidBySha256Hash is a free data retrieval call binding the contract method 0xfa04901f.
//
// Solidity: function getUuidBySha256Hash(sha256Hash bytes32) constant returns(bytes16)
func (_FilesData *FilesDataCallerSession) GetUuidBySha256Hash(sha256Hash [32]byte) ([16]byte, error) {
	return _FilesData.Contract.GetUuidBySha256Hash(&_FilesData.CallOpts, sha256Hash)
}

// GetUuidListSize is a free data retrieval call binding the contract method 0x6b303682.
//
// Solidity: function getUuidListSize() constant returns(uint256)
func (_FilesData *FilesDataCaller) GetUuidListSize(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "getUuidListSize")
	return *ret0, err
}

// GetUuidListSize is a free data retrieval call binding the contract method 0x6b303682.
//
// Solidity: function getUuidListSize() constant returns(uint256)
func (_FilesData *FilesDataSession) GetUuidListSize() (*big.Int, error) {
	return _FilesData.Contract.GetUuidListSize(&_FilesData.CallOpts)
}

// GetUuidListSize is a free data retrieval call binding the contract method 0x6b303682.
//
// Solidity: function getUuidListSize() constant returns(uint256)
func (_FilesData *FilesDataCallerSession) GetUuidListSize() (*big.Int, error) {
	return _FilesData.Contract.GetUuidListSize(&_FilesData.CallOpts)
}

// IsUuidExist is a free data retrieval call binding the contract method 0x8eeded90.
//
// Solidity: function isUuidExist(uuid bytes16) constant returns(bool)
func (_FilesData *FilesDataCaller) IsUuidExist(opts *bind.CallOpts, uuid [16]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _FilesData.contract.Call(opts, out, "isUuidExist", uuid)
	return *ret0, err
}

// IsUuidExist is a free data retrieval call binding the contract method 0x8eeded90.
//
// Solidity: function isUuidExist(uuid bytes16) constant returns(bool)
func (_FilesData *FilesDataSession) IsUuidExist(uuid [16]byte) (bool, error) {
	return _FilesData.Contract.IsUuidExist(&_FilesData.CallOpts, uuid)
}

// IsUuidExist is a free data retrieval call binding the contract method 0x8eeded90.
//
// Solidity: function isUuidExist(uuid bytes16) constant returns(bool)
func (_FilesData *FilesDataCallerSession) IsUuidExist(uuid [16]byte) (bool, error) {
	return _FilesData.Contract.IsUuidExist(&_FilesData.CallOpts, uuid)
}

// AddFile is a paid mutator transaction binding the contract method 0x81803062.
//
// Solidity: function addFile(uuid bytes16, ownerUuid bytes16, uploaderUuid bytes16, fileType bytes32, fileDesc bytes32[4], keccak256Hash bytes32, sha256Hash bytes32, r bytes32, s bytes32, v uint8, time uint256) returns()
func (_FilesData *FilesDataTransactor) AddFile(opts *bind.TransactOpts, uuid [16]byte, ownerUuid [16]byte, uploaderUuid [16]byte, fileType [32]byte, fileDesc [4][32]byte, keccak256Hash [32]byte, sha256Hash [32]byte, r [32]byte, s [32]byte, v uint8, time *big.Int) (*types.Transaction, error) {
	return _FilesData.contract.Transact(opts, "addFile", uuid, ownerUuid, uploaderUuid, fileType, fileDesc, keccak256Hash, sha256Hash, r, s, v, time)
}

// AddFile is a paid mutator transaction binding the contract method 0x81803062.
//
// Solidity: function addFile(uuid bytes16, ownerUuid bytes16, uploaderUuid bytes16, fileType bytes32, fileDesc bytes32[4], keccak256Hash bytes32, sha256Hash bytes32, r bytes32, s bytes32, v uint8, time uint256) returns()
func (_FilesData *FilesDataSession) AddFile(uuid [16]byte, ownerUuid [16]byte, uploaderUuid [16]byte, fileType [32]byte, fileDesc [4][32]byte, keccak256Hash [32]byte, sha256Hash [32]byte, r [32]byte, s [32]byte, v uint8, time *big.Int) (*types.Transaction, error) {
	return _FilesData.Contract.AddFile(&_FilesData.TransactOpts, uuid, ownerUuid, uploaderUuid, fileType, fileDesc, keccak256Hash, sha256Hash, r, s, v, time)
}

// AddFile is a paid mutator transaction binding the contract method 0x81803062.
//
// Solidity: function addFile(uuid bytes16, ownerUuid bytes16, uploaderUuid bytes16, fileType bytes32, fileDesc bytes32[4], keccak256Hash bytes32, sha256Hash bytes32, r bytes32, s bytes32, v uint8, time uint256) returns()
func (_FilesData *FilesDataTransactorSession) AddFile(uuid [16]byte, ownerUuid [16]byte, uploaderUuid [16]byte, fileType [32]byte, fileDesc [4][32]byte, keccak256Hash [32]byte, sha256Hash [32]byte, r [32]byte, s [32]byte, v uint8, time *big.Int) (*types.Transaction, error) {
	return _FilesData.Contract.AddFile(&_FilesData.TransactOpts, uuid, ownerUuid, uploaderUuid, fileType, fileDesc, keccak256Hash, sha256Hash, r, s, v, time)
}

// AddSign is a paid mutator transaction binding the contract method 0xaf1e3afc.
//
// Solidity: function addSign(uuid bytes16, userUuid bytes16, r bytes32, s bytes32, v uint8) returns()
func (_FilesData *FilesDataTransactor) AddSign(opts *bind.TransactOpts, uuid [16]byte, userUuid [16]byte, r [32]byte, s [32]byte, v uint8) (*types.Transaction, error) {
	return _FilesData.contract.Transact(opts, "addSign", uuid, userUuid, r, s, v)
}

// AddSign is a paid mutator transaction binding the contract method 0xaf1e3afc.
//
// Solidity: function addSign(uuid bytes16, userUuid bytes16, r bytes32, s bytes32, v uint8) returns()
func (_FilesData *FilesDataSession) AddSign(uuid [16]byte, userUuid [16]byte, r [32]byte, s [32]byte, v uint8) (*types.Transaction, error) {
	return _FilesData.Contract.AddSign(&_FilesData.TransactOpts, uuid, userUuid, r, s, v)
}

// AddSign is a paid mutator transaction binding the contract method 0xaf1e3afc.
//
// Solidity: function addSign(uuid bytes16, userUuid bytes16, r bytes32, s bytes32, v uint8) returns()
func (_FilesData *FilesDataTransactorSession) AddSign(uuid [16]byte, userUuid [16]byte, r [32]byte, s [32]byte, v uint8) (*types.Transaction, error) {
	return _FilesData.Contract.AddSign(&_FilesData.TransactOpts, uuid, userUuid, r, s, v)
}

// AddSuper is a paid mutator transaction binding the contract method 0xe1e8637b.
//
// Solidity: function addSuper(addr address) returns()
func (_FilesData *FilesDataTransactor) AddSuper(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _FilesData.contract.Transact(opts, "addSuper", addr)
}

// AddSuper is a paid mutator transaction binding the contract method 0xe1e8637b.
//
// Solidity: function addSuper(addr address) returns()
func (_FilesData *FilesDataSession) AddSuper(addr common.Address) (*types.Transaction, error) {
	return _FilesData.Contract.AddSuper(&_FilesData.TransactOpts, addr)
}

// AddSuper is a paid mutator transaction binding the contract method 0xe1e8637b.
//
// Solidity: function addSuper(addr address) returns()
func (_FilesData *FilesDataTransactorSession) AddSuper(addr common.Address) (*types.Transaction, error) {
	return _FilesData.Contract.AddSuper(&_FilesData.TransactOpts, addr)
}

// DelFile is a paid mutator transaction binding the contract method 0xab594cf6.
//
// Solidity: function delFile(uuid bytes16) returns()
func (_FilesData *FilesDataTransactor) DelFile(opts *bind.TransactOpts, uuid [16]byte) (*types.Transaction, error) {
	return _FilesData.contract.Transact(opts, "delFile", uuid)
}

// DelFile is a paid mutator transaction binding the contract method 0xab594cf6.
//
// Solidity: function delFile(uuid bytes16) returns()
func (_FilesData *FilesDataSession) DelFile(uuid [16]byte) (*types.Transaction, error) {
	return _FilesData.Contract.DelFile(&_FilesData.TransactOpts, uuid)
}

// DelFile is a paid mutator transaction binding the contract method 0xab594cf6.
//
// Solidity: function delFile(uuid bytes16) returns()
func (_FilesData *FilesDataTransactorSession) DelFile(uuid [16]byte) (*types.Transaction, error) {
	return _FilesData.Contract.DelFile(&_FilesData.TransactOpts, uuid)
}

// DelSuper is a paid mutator transaction binding the contract method 0x65f337f5.
//
// Solidity: function delSuper(addr address) returns()
func (_FilesData *FilesDataTransactor) DelSuper(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _FilesData.contract.Transact(opts, "delSuper", addr)
}

// DelSuper is a paid mutator transaction binding the contract method 0x65f337f5.
//
// Solidity: function delSuper(addr address) returns()
func (_FilesData *FilesDataSession) DelSuper(addr common.Address) (*types.Transaction, error) {
	return _FilesData.Contract.DelSuper(&_FilesData.TransactOpts, addr)
}

// DelSuper is a paid mutator transaction binding the contract method 0x65f337f5.
//
// Solidity: function delSuper(addr address) returns()
func (_FilesData *FilesDataTransactorSession) DelSuper(addr common.Address) (*types.Transaction, error) {
	return _FilesData.Contract.DelSuper(&_FilesData.TransactOpts, addr)
}

// SetActive is a paid mutator transaction binding the contract method 0x24716b55.
//
// Solidity: function setActive(uuid bytes16, active bool) returns()
func (_FilesData *FilesDataTransactor) SetActive(opts *bind.TransactOpts, uuid [16]byte, active bool) (*types.Transaction, error) {
	return _FilesData.contract.Transact(opts, "setActive", uuid, active)
}

// SetActive is a paid mutator transaction binding the contract method 0x24716b55.
//
// Solidity: function setActive(uuid bytes16, active bool) returns()
func (_FilesData *FilesDataSession) SetActive(uuid [16]byte, active bool) (*types.Transaction, error) {
	return _FilesData.Contract.SetActive(&_FilesData.TransactOpts, uuid, active)
}

// SetActive is a paid mutator transaction binding the contract method 0x24716b55.
//
// Solidity: function setActive(uuid bytes16, active bool) returns()
func (_FilesData *FilesDataTransactorSession) SetActive(uuid [16]byte, active bool) (*types.Transaction, error) {
	return _FilesData.Contract.SetActive(&_FilesData.TransactOpts, uuid, active)
}

// SetFileDesc is a paid mutator transaction binding the contract method 0xa06f2e46.
//
// Solidity: function setFileDesc(uuid bytes16, fileDesc bytes32[4]) returns()
func (_FilesData *FilesDataTransactor) SetFileDesc(opts *bind.TransactOpts, uuid [16]byte, fileDesc [4][32]byte) (*types.Transaction, error) {
	return _FilesData.contract.Transact(opts, "setFileDesc", uuid, fileDesc)
}

// SetFileDesc is a paid mutator transaction binding the contract method 0xa06f2e46.
//
// Solidity: function setFileDesc(uuid bytes16, fileDesc bytes32[4]) returns()
func (_FilesData *FilesDataSession) SetFileDesc(uuid [16]byte, fileDesc [4][32]byte) (*types.Transaction, error) {
	return _FilesData.Contract.SetFileDesc(&_FilesData.TransactOpts, uuid, fileDesc)
}

// SetFileDesc is a paid mutator transaction binding the contract method 0xa06f2e46.
//
// Solidity: function setFileDesc(uuid bytes16, fileDesc bytes32[4]) returns()
func (_FilesData *FilesDataTransactorSession) SetFileDesc(uuid [16]byte, fileDesc [4][32]byte) (*types.Transaction, error) {
	return _FilesData.Contract.SetFileDesc(&_FilesData.TransactOpts, uuid, fileDesc)
}

// SetFileType is a paid mutator transaction binding the contract method 0x28360cdd.
//
// Solidity: function setFileType(uuid bytes16, fileType bytes32) returns()
func (_FilesData *FilesDataTransactor) SetFileType(opts *bind.TransactOpts, uuid [16]byte, fileType [32]byte) (*types.Transaction, error) {
	return _FilesData.contract.Transact(opts, "setFileType", uuid, fileType)
}

// SetFileType is a paid mutator transaction binding the contract method 0x28360cdd.
//
// Solidity: function setFileType(uuid bytes16, fileType bytes32) returns()
func (_FilesData *FilesDataSession) SetFileType(uuid [16]byte, fileType [32]byte) (*types.Transaction, error) {
	return _FilesData.Contract.SetFileType(&_FilesData.TransactOpts, uuid, fileType)
}

// SetFileType is a paid mutator transaction binding the contract method 0x28360cdd.
//
// Solidity: function setFileType(uuid bytes16, fileType bytes32) returns()
func (_FilesData *FilesDataTransactorSession) SetFileType(uuid [16]byte, fileType [32]byte) (*types.Transaction, error) {
	return _FilesData.Contract.SetFileType(&_FilesData.TransactOpts, uuid, fileType)
}

// SetOwnerUuid is a paid mutator transaction binding the contract method 0x2f682a60.
//
// Solidity: function setOwnerUuid(uuid bytes16, ownerUuid bytes16) returns()
func (_FilesData *FilesDataTransactor) SetOwnerUuid(opts *bind.TransactOpts, uuid [16]byte, ownerUuid [16]byte) (*types.Transaction, error) {
	return _FilesData.contract.Transact(opts, "setOwnerUuid", uuid, ownerUuid)
}

// SetOwnerUuid is a paid mutator transaction binding the contract method 0x2f682a60.
//
// Solidity: function setOwnerUuid(uuid bytes16, ownerUuid bytes16) returns()
func (_FilesData *FilesDataSession) SetOwnerUuid(uuid [16]byte, ownerUuid [16]byte) (*types.Transaction, error) {
	return _FilesData.Contract.SetOwnerUuid(&_FilesData.TransactOpts, uuid, ownerUuid)
}

// SetOwnerUuid is a paid mutator transaction binding the contract method 0x2f682a60.
//
// Solidity: function setOwnerUuid(uuid bytes16, ownerUuid bytes16) returns()
func (_FilesData *FilesDataTransactorSession) SetOwnerUuid(uuid [16]byte, ownerUuid [16]byte) (*types.Transaction, error) {
	return _FilesData.Contract.SetOwnerUuid(&_FilesData.TransactOpts, uuid, ownerUuid)
}

// SetTime is a paid mutator transaction binding the contract method 0x3f7a52b6.
//
// Solidity: function setTime(uuid bytes16, time uint256) returns()
func (_FilesData *FilesDataTransactor) SetTime(opts *bind.TransactOpts, uuid [16]byte, time *big.Int) (*types.Transaction, error) {
	return _FilesData.contract.Transact(opts, "setTime", uuid, time)
}

// SetTime is a paid mutator transaction binding the contract method 0x3f7a52b6.
//
// Solidity: function setTime(uuid bytes16, time uint256) returns()
func (_FilesData *FilesDataSession) SetTime(uuid [16]byte, time *big.Int) (*types.Transaction, error) {
	return _FilesData.Contract.SetTime(&_FilesData.TransactOpts, uuid, time)
}

// SetTime is a paid mutator transaction binding the contract method 0x3f7a52b6.
//
// Solidity: function setTime(uuid bytes16, time uint256) returns()
func (_FilesData *FilesDataTransactorSession) SetTime(uuid [16]byte, time *big.Int) (*types.Transaction, error) {
	return _FilesData.Contract.SetTime(&_FilesData.TransactOpts, uuid, time)
}

// SetUploaderUuid is a paid mutator transaction binding the contract method 0x6c75a331.
//
// Solidity: function setUploaderUuid(uuid bytes16, uploaderUuid bytes16) returns()
func (_FilesData *FilesDataTransactor) SetUploaderUuid(opts *bind.TransactOpts, uuid [16]byte, uploaderUuid [16]byte) (*types.Transaction, error) {
	return _FilesData.contract.Transact(opts, "setUploaderUuid", uuid, uploaderUuid)
}

// SetUploaderUuid is a paid mutator transaction binding the contract method 0x6c75a331.
//
// Solidity: function setUploaderUuid(uuid bytes16, uploaderUuid bytes16) returns()
func (_FilesData *FilesDataSession) SetUploaderUuid(uuid [16]byte, uploaderUuid [16]byte) (*types.Transaction, error) {
	return _FilesData.Contract.SetUploaderUuid(&_FilesData.TransactOpts, uuid, uploaderUuid)
}

// SetUploaderUuid is a paid mutator transaction binding the contract method 0x6c75a331.
//
// Solidity: function setUploaderUuid(uuid bytes16, uploaderUuid bytes16) returns()
func (_FilesData *FilesDataTransactorSession) SetUploaderUuid(uuid [16]byte, uploaderUuid [16]byte) (*types.Transaction, error) {
	return _FilesData.Contract.SetUploaderUuid(&_FilesData.TransactOpts, uuid, uploaderUuid)
}

// FilesDataOnAddFileIterator is returned from FilterOnAddFile and is used to iterate over the raw logs and unpacked data for OnAddFile events raised by the FilesData contract.
type FilesDataOnAddFileIterator struct {
	Event *FilesDataOnAddFile // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddFileIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddFile)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddFile)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddFileIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddFileIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddFile represents a OnAddFile event raised by the FilesData contract.
type FilesDataOnAddFile struct {
	Uuid          [16]byte
	OwnerUuid     [16]byte
	UploaderUuid  [16]byte
	FileType      [32]byte
	FileDesc      [4][32]byte
	Keccak256Hash [32]byte
	Sha256Hash    [32]byte
	R             [32]byte
	S             [32]byte
	V             uint8
	Time          *big.Int
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOnAddFile is a free log retrieval operation binding the contract event 0xe5db0782a88ef1dd5e05dbcd66036151fdd928c04a041691230dff05e269440a.
//
// Solidity: e onAddFile(uuid bytes16, ownerUuid bytes16, uploaderUuid bytes16, fileType bytes32, fileDesc bytes32[4], keccak256Hash bytes32, sha256Hash bytes32, r bytes32, s bytes32, v uint8, time uint256)
func (_FilesData *FilesDataFilterer) FilterOnAddFile(opts *bind.FilterOpts) (*FilesDataOnAddFileIterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddFile")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddFileIterator{contract: _FilesData.contract, event: "onAddFile", logs: logs, sub: sub}, nil
}

// WatchOnAddFile is a free log subscription operation binding the contract event 0xe5db0782a88ef1dd5e05dbcd66036151fdd928c04a041691230dff05e269440a.
//
// Solidity: e onAddFile(uuid bytes16, ownerUuid bytes16, uploaderUuid bytes16, fileType bytes32, fileDesc bytes32[4], keccak256Hash bytes32, sha256Hash bytes32, r bytes32, s bytes32, v uint8, time uint256)
func (_FilesData *FilesDataFilterer) WatchOnAddFile(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddFile) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddFile")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddFile)
				if err := _FilesData.contract.UnpackLog(event, "onAddFile", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddFileStep0Iterator is returned from FilterOnAddFileStep0 and is used to iterate over the raw logs and unpacked data for OnAddFileStep0 events raised by the FilesData contract.
type FilesDataOnAddFileStep0Iterator struct {
	Event *FilesDataOnAddFileStep0 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddFileStep0Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddFileStep0)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddFileStep0)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddFileStep0Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddFileStep0Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddFileStep0 represents a OnAddFileStep0 event raised by the FilesData contract.
type FilesDataOnAddFileStep0 struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOnAddFileStep0 is a free log retrieval operation binding the contract event 0x4e256027454af3fd26f7e7a4b0750730b68989b274617b76483487b92d039f6d.
//
// Solidity: e onAddFileStep0()
func (_FilesData *FilesDataFilterer) FilterOnAddFileStep0(opts *bind.FilterOpts) (*FilesDataOnAddFileStep0Iterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddFileStep0")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddFileStep0Iterator{contract: _FilesData.contract, event: "onAddFileStep0", logs: logs, sub: sub}, nil
}

// WatchOnAddFileStep0 is a free log subscription operation binding the contract event 0x4e256027454af3fd26f7e7a4b0750730b68989b274617b76483487b92d039f6d.
//
// Solidity: e onAddFileStep0()
func (_FilesData *FilesDataFilterer) WatchOnAddFileStep0(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddFileStep0) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddFileStep0")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddFileStep0)
				if err := _FilesData.contract.UnpackLog(event, "onAddFileStep0", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddFileStep1Iterator is returned from FilterOnAddFileStep1 and is used to iterate over the raw logs and unpacked data for OnAddFileStep1 events raised by the FilesData contract.
type FilesDataOnAddFileStep1Iterator struct {
	Event *FilesDataOnAddFileStep1 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddFileStep1Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddFileStep1)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddFileStep1)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddFileStep1Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddFileStep1Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddFileStep1 represents a OnAddFileStep1 event raised by the FilesData contract.
type FilesDataOnAddFileStep1 struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOnAddFileStep1 is a free log retrieval operation binding the contract event 0xc9092c490974ca78edff24ade5ce5823286cf026469669fae88fdf1f7fc3107d.
//
// Solidity: e onAddFileStep1()
func (_FilesData *FilesDataFilterer) FilterOnAddFileStep1(opts *bind.FilterOpts) (*FilesDataOnAddFileStep1Iterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddFileStep1")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddFileStep1Iterator{contract: _FilesData.contract, event: "onAddFileStep1", logs: logs, sub: sub}, nil
}

// WatchOnAddFileStep1 is a free log subscription operation binding the contract event 0xc9092c490974ca78edff24ade5ce5823286cf026469669fae88fdf1f7fc3107d.
//
// Solidity: e onAddFileStep1()
func (_FilesData *FilesDataFilterer) WatchOnAddFileStep1(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddFileStep1) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddFileStep1")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddFileStep1)
				if err := _FilesData.contract.UnpackLog(event, "onAddFileStep1", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddFileStep10Iterator is returned from FilterOnAddFileStep10 and is used to iterate over the raw logs and unpacked data for OnAddFileStep10 events raised by the FilesData contract.
type FilesDataOnAddFileStep10Iterator struct {
	Event *FilesDataOnAddFileStep10 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddFileStep10Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddFileStep10)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddFileStep10)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddFileStep10Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddFileStep10Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddFileStep10 represents a OnAddFileStep10 event raised by the FilesData contract.
type FilesDataOnAddFileStep10 struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOnAddFileStep10 is a free log retrieval operation binding the contract event 0x20fed4367af743411a2085709baea3083d7b76275447358cf5fe0c92a70df37d.
//
// Solidity: e onAddFileStep10()
func (_FilesData *FilesDataFilterer) FilterOnAddFileStep10(opts *bind.FilterOpts) (*FilesDataOnAddFileStep10Iterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddFileStep10")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddFileStep10Iterator{contract: _FilesData.contract, event: "onAddFileStep10", logs: logs, sub: sub}, nil
}

// WatchOnAddFileStep10 is a free log subscription operation binding the contract event 0x20fed4367af743411a2085709baea3083d7b76275447358cf5fe0c92a70df37d.
//
// Solidity: e onAddFileStep10()
func (_FilesData *FilesDataFilterer) WatchOnAddFileStep10(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddFileStep10) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddFileStep10")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddFileStep10)
				if err := _FilesData.contract.UnpackLog(event, "onAddFileStep10", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddFileStep2Iterator is returned from FilterOnAddFileStep2 and is used to iterate over the raw logs and unpacked data for OnAddFileStep2 events raised by the FilesData contract.
type FilesDataOnAddFileStep2Iterator struct {
	Event *FilesDataOnAddFileStep2 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddFileStep2Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddFileStep2)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddFileStep2)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddFileStep2Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddFileStep2Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddFileStep2 represents a OnAddFileStep2 event raised by the FilesData contract.
type FilesDataOnAddFileStep2 struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOnAddFileStep2 is a free log retrieval operation binding the contract event 0x21cec0860cd4ae6e7e471e67e6c1aa086aff871e1f8b0cdbbf74422091aec59a.
//
// Solidity: e onAddFileStep2()
func (_FilesData *FilesDataFilterer) FilterOnAddFileStep2(opts *bind.FilterOpts) (*FilesDataOnAddFileStep2Iterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddFileStep2")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddFileStep2Iterator{contract: _FilesData.contract, event: "onAddFileStep2", logs: logs, sub: sub}, nil
}

// WatchOnAddFileStep2 is a free log subscription operation binding the contract event 0x21cec0860cd4ae6e7e471e67e6c1aa086aff871e1f8b0cdbbf74422091aec59a.
//
// Solidity: e onAddFileStep2()
func (_FilesData *FilesDataFilterer) WatchOnAddFileStep2(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddFileStep2) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddFileStep2")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddFileStep2)
				if err := _FilesData.contract.UnpackLog(event, "onAddFileStep2", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddFileStep3Iterator is returned from FilterOnAddFileStep3 and is used to iterate over the raw logs and unpacked data for OnAddFileStep3 events raised by the FilesData contract.
type FilesDataOnAddFileStep3Iterator struct {
	Event *FilesDataOnAddFileStep3 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddFileStep3Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddFileStep3)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddFileStep3)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddFileStep3Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddFileStep3Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddFileStep3 represents a OnAddFileStep3 event raised by the FilesData contract.
type FilesDataOnAddFileStep3 struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOnAddFileStep3 is a free log retrieval operation binding the contract event 0x401b65eb74bb9440b894a8c652928199f339b16dd0eb491c43b7221b54598ccf.
//
// Solidity: e onAddFileStep3()
func (_FilesData *FilesDataFilterer) FilterOnAddFileStep3(opts *bind.FilterOpts) (*FilesDataOnAddFileStep3Iterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddFileStep3")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddFileStep3Iterator{contract: _FilesData.contract, event: "onAddFileStep3", logs: logs, sub: sub}, nil
}

// WatchOnAddFileStep3 is a free log subscription operation binding the contract event 0x401b65eb74bb9440b894a8c652928199f339b16dd0eb491c43b7221b54598ccf.
//
// Solidity: e onAddFileStep3()
func (_FilesData *FilesDataFilterer) WatchOnAddFileStep3(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddFileStep3) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddFileStep3")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddFileStep3)
				if err := _FilesData.contract.UnpackLog(event, "onAddFileStep3", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddFileStep4Iterator is returned from FilterOnAddFileStep4 and is used to iterate over the raw logs and unpacked data for OnAddFileStep4 events raised by the FilesData contract.
type FilesDataOnAddFileStep4Iterator struct {
	Event *FilesDataOnAddFileStep4 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddFileStep4Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddFileStep4)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddFileStep4)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddFileStep4Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddFileStep4Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddFileStep4 represents a OnAddFileStep4 event raised by the FilesData contract.
type FilesDataOnAddFileStep4 struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOnAddFileStep4 is a free log retrieval operation binding the contract event 0x7c6defcd62215168345bf11fbaf699551d6fece54ea6aeb1dbf22a9dd2e9bffb.
//
// Solidity: e onAddFileStep4()
func (_FilesData *FilesDataFilterer) FilterOnAddFileStep4(opts *bind.FilterOpts) (*FilesDataOnAddFileStep4Iterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddFileStep4")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddFileStep4Iterator{contract: _FilesData.contract, event: "onAddFileStep4", logs: logs, sub: sub}, nil
}

// WatchOnAddFileStep4 is a free log subscription operation binding the contract event 0x7c6defcd62215168345bf11fbaf699551d6fece54ea6aeb1dbf22a9dd2e9bffb.
//
// Solidity: e onAddFileStep4()
func (_FilesData *FilesDataFilterer) WatchOnAddFileStep4(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddFileStep4) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddFileStep4")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddFileStep4)
				if err := _FilesData.contract.UnpackLog(event, "onAddFileStep4", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddFileStep5Iterator is returned from FilterOnAddFileStep5 and is used to iterate over the raw logs and unpacked data for OnAddFileStep5 events raised by the FilesData contract.
type FilesDataOnAddFileStep5Iterator struct {
	Event *FilesDataOnAddFileStep5 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddFileStep5Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddFileStep5)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddFileStep5)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddFileStep5Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddFileStep5Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddFileStep5 represents a OnAddFileStep5 event raised by the FilesData contract.
type FilesDataOnAddFileStep5 struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOnAddFileStep5 is a free log retrieval operation binding the contract event 0xa5774a70b1b4f1cc2714527a0f324a7f2162ad09def964bc5d6e84410414239c.
//
// Solidity: e onAddFileStep5()
func (_FilesData *FilesDataFilterer) FilterOnAddFileStep5(opts *bind.FilterOpts) (*FilesDataOnAddFileStep5Iterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddFileStep5")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddFileStep5Iterator{contract: _FilesData.contract, event: "onAddFileStep5", logs: logs, sub: sub}, nil
}

// WatchOnAddFileStep5 is a free log subscription operation binding the contract event 0xa5774a70b1b4f1cc2714527a0f324a7f2162ad09def964bc5d6e84410414239c.
//
// Solidity: e onAddFileStep5()
func (_FilesData *FilesDataFilterer) WatchOnAddFileStep5(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddFileStep5) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddFileStep5")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddFileStep5)
				if err := _FilesData.contract.UnpackLog(event, "onAddFileStep5", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddFileStep6Iterator is returned from FilterOnAddFileStep6 and is used to iterate over the raw logs and unpacked data for OnAddFileStep6 events raised by the FilesData contract.
type FilesDataOnAddFileStep6Iterator struct {
	Event *FilesDataOnAddFileStep6 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddFileStep6Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddFileStep6)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddFileStep6)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddFileStep6Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddFileStep6Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddFileStep6 represents a OnAddFileStep6 event raised by the FilesData contract.
type FilesDataOnAddFileStep6 struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOnAddFileStep6 is a free log retrieval operation binding the contract event 0x1c97ebd961ba4bbbf42bb3521f5daee73a4c427c662f74b7e5d6e826720d89dc.
//
// Solidity: e onAddFileStep6()
func (_FilesData *FilesDataFilterer) FilterOnAddFileStep6(opts *bind.FilterOpts) (*FilesDataOnAddFileStep6Iterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddFileStep6")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddFileStep6Iterator{contract: _FilesData.contract, event: "onAddFileStep6", logs: logs, sub: sub}, nil
}

// WatchOnAddFileStep6 is a free log subscription operation binding the contract event 0x1c97ebd961ba4bbbf42bb3521f5daee73a4c427c662f74b7e5d6e826720d89dc.
//
// Solidity: e onAddFileStep6()
func (_FilesData *FilesDataFilterer) WatchOnAddFileStep6(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddFileStep6) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddFileStep6")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddFileStep6)
				if err := _FilesData.contract.UnpackLog(event, "onAddFileStep6", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddFileStep7Iterator is returned from FilterOnAddFileStep7 and is used to iterate over the raw logs and unpacked data for OnAddFileStep7 events raised by the FilesData contract.
type FilesDataOnAddFileStep7Iterator struct {
	Event *FilesDataOnAddFileStep7 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddFileStep7Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddFileStep7)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddFileStep7)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddFileStep7Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddFileStep7Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddFileStep7 represents a OnAddFileStep7 event raised by the FilesData contract.
type FilesDataOnAddFileStep7 struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOnAddFileStep7 is a free log retrieval operation binding the contract event 0x95e48219dccf7d1198e016684404154f0f96701dd80d95c9f3699e4235b9cbd2.
//
// Solidity: e onAddFileStep7()
func (_FilesData *FilesDataFilterer) FilterOnAddFileStep7(opts *bind.FilterOpts) (*FilesDataOnAddFileStep7Iterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddFileStep7")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddFileStep7Iterator{contract: _FilesData.contract, event: "onAddFileStep7", logs: logs, sub: sub}, nil
}

// WatchOnAddFileStep7 is a free log subscription operation binding the contract event 0x95e48219dccf7d1198e016684404154f0f96701dd80d95c9f3699e4235b9cbd2.
//
// Solidity: e onAddFileStep7()
func (_FilesData *FilesDataFilterer) WatchOnAddFileStep7(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddFileStep7) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddFileStep7")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddFileStep7)
				if err := _FilesData.contract.UnpackLog(event, "onAddFileStep7", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddFileStep8Iterator is returned from FilterOnAddFileStep8 and is used to iterate over the raw logs and unpacked data for OnAddFileStep8 events raised by the FilesData contract.
type FilesDataOnAddFileStep8Iterator struct {
	Event *FilesDataOnAddFileStep8 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddFileStep8Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddFileStep8)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddFileStep8)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddFileStep8Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddFileStep8Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddFileStep8 represents a OnAddFileStep8 event raised by the FilesData contract.
type FilesDataOnAddFileStep8 struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOnAddFileStep8 is a free log retrieval operation binding the contract event 0x8bbe4c49460cf84693c316a80adb0bc97b4c8e5f2de3e0c8f8a18243c03446ea.
//
// Solidity: e onAddFileStep8()
func (_FilesData *FilesDataFilterer) FilterOnAddFileStep8(opts *bind.FilterOpts) (*FilesDataOnAddFileStep8Iterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddFileStep8")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddFileStep8Iterator{contract: _FilesData.contract, event: "onAddFileStep8", logs: logs, sub: sub}, nil
}

// WatchOnAddFileStep8 is a free log subscription operation binding the contract event 0x8bbe4c49460cf84693c316a80adb0bc97b4c8e5f2de3e0c8f8a18243c03446ea.
//
// Solidity: e onAddFileStep8()
func (_FilesData *FilesDataFilterer) WatchOnAddFileStep8(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddFileStep8) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddFileStep8")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddFileStep8)
				if err := _FilesData.contract.UnpackLog(event, "onAddFileStep8", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddFileStep9Iterator is returned from FilterOnAddFileStep9 and is used to iterate over the raw logs and unpacked data for OnAddFileStep9 events raised by the FilesData contract.
type FilesDataOnAddFileStep9Iterator struct {
	Event *FilesDataOnAddFileStep9 // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddFileStep9Iterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddFileStep9)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddFileStep9)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddFileStep9Iterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddFileStep9Iterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddFileStep9 represents a OnAddFileStep9 event raised by the FilesData contract.
type FilesDataOnAddFileStep9 struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOnAddFileStep9 is a free log retrieval operation binding the contract event 0x8239e34ad72fee63b4ead914623b739d0d8a030b0e0da2d87f05a939e0d6e58a.
//
// Solidity: e onAddFileStep9()
func (_FilesData *FilesDataFilterer) FilterOnAddFileStep9(opts *bind.FilterOpts) (*FilesDataOnAddFileStep9Iterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddFileStep9")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddFileStep9Iterator{contract: _FilesData.contract, event: "onAddFileStep9", logs: logs, sub: sub}, nil
}

// WatchOnAddFileStep9 is a free log subscription operation binding the contract event 0x8239e34ad72fee63b4ead914623b739d0d8a030b0e0da2d87f05a939e0d6e58a.
//
// Solidity: e onAddFileStep9()
func (_FilesData *FilesDataFilterer) WatchOnAddFileStep9(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddFileStep9) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddFileStep9")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddFileStep9)
				if err := _FilesData.contract.UnpackLog(event, "onAddFileStep9", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddSignIterator is returned from FilterOnAddSign and is used to iterate over the raw logs and unpacked data for OnAddSign events raised by the FilesData contract.
type FilesDataOnAddSignIterator struct {
	Event *FilesDataOnAddSign // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddSignIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddSign)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddSign)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddSignIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddSignIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddSign represents a OnAddSign event raised by the FilesData contract.
type FilesDataOnAddSign struct {
	Uuid     [16]byte
	UserUuid [16]byte
	R        [32]byte
	S        [32]byte
	V        uint8
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOnAddSign is a free log retrieval operation binding the contract event 0xb6d8f3f2b7e44359d0f3577f248b9a9b8e6c275f3c9b6752d9c6905a0d18a2ac.
//
// Solidity: e onAddSign(uuid bytes16, userUuid bytes16, r bytes32, s bytes32, v uint8)
func (_FilesData *FilesDataFilterer) FilterOnAddSign(opts *bind.FilterOpts) (*FilesDataOnAddSignIterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddSign")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddSignIterator{contract: _FilesData.contract, event: "onAddSign", logs: logs, sub: sub}, nil
}

// WatchOnAddSign is a free log subscription operation binding the contract event 0xb6d8f3f2b7e44359d0f3577f248b9a9b8e6c275f3c9b6752d9c6905a0d18a2ac.
//
// Solidity: e onAddSign(uuid bytes16, userUuid bytes16, r bytes32, s bytes32, v uint8)
func (_FilesData *FilesDataFilterer) WatchOnAddSign(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddSign) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddSign")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddSign)
				if err := _FilesData.contract.UnpackLog(event, "onAddSign", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnAddSuperIterator is returned from FilterOnAddSuper and is used to iterate over the raw logs and unpacked data for OnAddSuper events raised by the FilesData contract.
type FilesDataOnAddSuperIterator struct {
	Event *FilesDataOnAddSuper // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnAddSuperIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnAddSuper)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnAddSuper)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnAddSuperIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnAddSuperIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnAddSuper represents a OnAddSuper event raised by the FilesData contract.
type FilesDataOnAddSuper struct {
	Addr common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterOnAddSuper is a free log retrieval operation binding the contract event 0x920999c03a7fd19172e4c657c22aa62a1bfb5e027a8cf6a2a0ee9daf4c5a3474.
//
// Solidity: e onAddSuper(addr address)
func (_FilesData *FilesDataFilterer) FilterOnAddSuper(opts *bind.FilterOpts) (*FilesDataOnAddSuperIterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onAddSuper")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnAddSuperIterator{contract: _FilesData.contract, event: "onAddSuper", logs: logs, sub: sub}, nil
}

// WatchOnAddSuper is a free log subscription operation binding the contract event 0x920999c03a7fd19172e4c657c22aa62a1bfb5e027a8cf6a2a0ee9daf4c5a3474.
//
// Solidity: e onAddSuper(addr address)
func (_FilesData *FilesDataFilterer) WatchOnAddSuper(opts *bind.WatchOpts, sink chan<- *FilesDataOnAddSuper) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onAddSuper")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnAddSuper)
				if err := _FilesData.contract.UnpackLog(event, "onAddSuper", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnDelFileIterator is returned from FilterOnDelFile and is used to iterate over the raw logs and unpacked data for OnDelFile events raised by the FilesData contract.
type FilesDataOnDelFileIterator struct {
	Event *FilesDataOnDelFile // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnDelFileIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnDelFile)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnDelFile)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnDelFileIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnDelFileIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnDelFile represents a OnDelFile event raised by the FilesData contract.
type FilesDataOnDelFile struct {
	Uuid [16]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterOnDelFile is a free log retrieval operation binding the contract event 0x5084265f9b0b758e57a9c7d957106776471ed835d7267fb54d933927a3481bfd.
//
// Solidity: e onDelFile(uuid bytes16)
func (_FilesData *FilesDataFilterer) FilterOnDelFile(opts *bind.FilterOpts) (*FilesDataOnDelFileIterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onDelFile")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnDelFileIterator{contract: _FilesData.contract, event: "onDelFile", logs: logs, sub: sub}, nil
}

// WatchOnDelFile is a free log subscription operation binding the contract event 0x5084265f9b0b758e57a9c7d957106776471ed835d7267fb54d933927a3481bfd.
//
// Solidity: e onDelFile(uuid bytes16)
func (_FilesData *FilesDataFilterer) WatchOnDelFile(opts *bind.WatchOpts, sink chan<- *FilesDataOnDelFile) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onDelFile")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnDelFile)
				if err := _FilesData.contract.UnpackLog(event, "onDelFile", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnDelSuperIterator is returned from FilterOnDelSuper and is used to iterate over the raw logs and unpacked data for OnDelSuper events raised by the FilesData contract.
type FilesDataOnDelSuperIterator struct {
	Event *FilesDataOnDelSuper // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnDelSuperIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnDelSuper)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnDelSuper)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnDelSuperIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnDelSuperIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnDelSuper represents a OnDelSuper event raised by the FilesData contract.
type FilesDataOnDelSuper struct {
	Addr common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterOnDelSuper is a free log retrieval operation binding the contract event 0x5561c1cda602083d14af2f0773152f273f6f9bf8feb17ce6265f94aec25bde00.
//
// Solidity: e onDelSuper(addr address)
func (_FilesData *FilesDataFilterer) FilterOnDelSuper(opts *bind.FilterOpts) (*FilesDataOnDelSuperIterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onDelSuper")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnDelSuperIterator{contract: _FilesData.contract, event: "onDelSuper", logs: logs, sub: sub}, nil
}

// WatchOnDelSuper is a free log subscription operation binding the contract event 0x5561c1cda602083d14af2f0773152f273f6f9bf8feb17ce6265f94aec25bde00.
//
// Solidity: e onDelSuper(addr address)
func (_FilesData *FilesDataFilterer) WatchOnDelSuper(opts *bind.WatchOpts, sink chan<- *FilesDataOnDelSuper) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onDelSuper")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnDelSuper)
				if err := _FilesData.contract.UnpackLog(event, "onDelSuper", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnSetActiveIterator is returned from FilterOnSetActive and is used to iterate over the raw logs and unpacked data for OnSetActive events raised by the FilesData contract.
type FilesDataOnSetActiveIterator struct {
	Event *FilesDataOnSetActive // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnSetActiveIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnSetActive)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnSetActive)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnSetActiveIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnSetActiveIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnSetActive represents a OnSetActive event raised by the FilesData contract.
type FilesDataOnSetActive struct {
	Uuid   [16]byte
	Active bool
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterOnSetActive is a free log retrieval operation binding the contract event 0x713e572bb47b301d3993c6d748aa8f43912b3e2864d1fd701e16e586fbb53905.
//
// Solidity: e onSetActive(uuid bytes16, active bool)
func (_FilesData *FilesDataFilterer) FilterOnSetActive(opts *bind.FilterOpts) (*FilesDataOnSetActiveIterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onSetActive")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnSetActiveIterator{contract: _FilesData.contract, event: "onSetActive", logs: logs, sub: sub}, nil
}

// WatchOnSetActive is a free log subscription operation binding the contract event 0x713e572bb47b301d3993c6d748aa8f43912b3e2864d1fd701e16e586fbb53905.
//
// Solidity: e onSetActive(uuid bytes16, active bool)
func (_FilesData *FilesDataFilterer) WatchOnSetActive(opts *bind.WatchOpts, sink chan<- *FilesDataOnSetActive) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onSetActive")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnSetActive)
				if err := _FilesData.contract.UnpackLog(event, "onSetActive", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnSetFileDescIterator is returned from FilterOnSetFileDesc and is used to iterate over the raw logs and unpacked data for OnSetFileDesc events raised by the FilesData contract.
type FilesDataOnSetFileDescIterator struct {
	Event *FilesDataOnSetFileDesc // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnSetFileDescIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnSetFileDesc)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnSetFileDesc)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnSetFileDescIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnSetFileDescIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnSetFileDesc represents a OnSetFileDesc event raised by the FilesData contract.
type FilesDataOnSetFileDesc struct {
	Uuid     [16]byte
	FileDesc [4][32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOnSetFileDesc is a free log retrieval operation binding the contract event 0x62c9cfebd42861a16451b2ce63bf3d3e5bcdb62acbc46482d52d0c48d34eb9b3.
//
// Solidity: e onSetFileDesc(uuid bytes16, fileDesc bytes32[4])
func (_FilesData *FilesDataFilterer) FilterOnSetFileDesc(opts *bind.FilterOpts) (*FilesDataOnSetFileDescIterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onSetFileDesc")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnSetFileDescIterator{contract: _FilesData.contract, event: "onSetFileDesc", logs: logs, sub: sub}, nil
}

// WatchOnSetFileDesc is a free log subscription operation binding the contract event 0x62c9cfebd42861a16451b2ce63bf3d3e5bcdb62acbc46482d52d0c48d34eb9b3.
//
// Solidity: e onSetFileDesc(uuid bytes16, fileDesc bytes32[4])
func (_FilesData *FilesDataFilterer) WatchOnSetFileDesc(opts *bind.WatchOpts, sink chan<- *FilesDataOnSetFileDesc) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onSetFileDesc")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnSetFileDesc)
				if err := _FilesData.contract.UnpackLog(event, "onSetFileDesc", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnSetFileTypeIterator is returned from FilterOnSetFileType and is used to iterate over the raw logs and unpacked data for OnSetFileType events raised by the FilesData contract.
type FilesDataOnSetFileTypeIterator struct {
	Event *FilesDataOnSetFileType // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnSetFileTypeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnSetFileType)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnSetFileType)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnSetFileTypeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnSetFileTypeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnSetFileType represents a OnSetFileType event raised by the FilesData contract.
type FilesDataOnSetFileType struct {
	Uuid     [16]byte
	FileType [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOnSetFileType is a free log retrieval operation binding the contract event 0x0f5d2a1fd7e620b5060ef0c66774a0475af737bef138fc169dfa8aca450e3899.
//
// Solidity: e onSetFileType(uuid bytes16, fileType bytes32)
func (_FilesData *FilesDataFilterer) FilterOnSetFileType(opts *bind.FilterOpts) (*FilesDataOnSetFileTypeIterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onSetFileType")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnSetFileTypeIterator{contract: _FilesData.contract, event: "onSetFileType", logs: logs, sub: sub}, nil
}

// WatchOnSetFileType is a free log subscription operation binding the contract event 0x0f5d2a1fd7e620b5060ef0c66774a0475af737bef138fc169dfa8aca450e3899.
//
// Solidity: e onSetFileType(uuid bytes16, fileType bytes32)
func (_FilesData *FilesDataFilterer) WatchOnSetFileType(opts *bind.WatchOpts, sink chan<- *FilesDataOnSetFileType) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onSetFileType")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnSetFileType)
				if err := _FilesData.contract.UnpackLog(event, "onSetFileType", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnSetOwnerUuidIterator is returned from FilterOnSetOwnerUuid and is used to iterate over the raw logs and unpacked data for OnSetOwnerUuid events raised by the FilesData contract.
type FilesDataOnSetOwnerUuidIterator struct {
	Event *FilesDataOnSetOwnerUuid // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnSetOwnerUuidIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnSetOwnerUuid)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnSetOwnerUuid)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnSetOwnerUuidIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnSetOwnerUuidIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnSetOwnerUuid represents a OnSetOwnerUuid event raised by the FilesData contract.
type FilesDataOnSetOwnerUuid struct {
	Uuid      [16]byte
	OwnerUuid [16]byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterOnSetOwnerUuid is a free log retrieval operation binding the contract event 0x82e7473892dc1da52c17ad55ae9ce073d7e153c1313b43a75527e983c42f9c66.
//
// Solidity: e onSetOwnerUuid(uuid bytes16, ownerUuid bytes16)
func (_FilesData *FilesDataFilterer) FilterOnSetOwnerUuid(opts *bind.FilterOpts) (*FilesDataOnSetOwnerUuidIterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onSetOwnerUuid")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnSetOwnerUuidIterator{contract: _FilesData.contract, event: "onSetOwnerUuid", logs: logs, sub: sub}, nil
}

// WatchOnSetOwnerUuid is a free log subscription operation binding the contract event 0x82e7473892dc1da52c17ad55ae9ce073d7e153c1313b43a75527e983c42f9c66.
//
// Solidity: e onSetOwnerUuid(uuid bytes16, ownerUuid bytes16)
func (_FilesData *FilesDataFilterer) WatchOnSetOwnerUuid(opts *bind.WatchOpts, sink chan<- *FilesDataOnSetOwnerUuid) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onSetOwnerUuid")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnSetOwnerUuid)
				if err := _FilesData.contract.UnpackLog(event, "onSetOwnerUuid", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnSetTimeIterator is returned from FilterOnSetTime and is used to iterate over the raw logs and unpacked data for OnSetTime events raised by the FilesData contract.
type FilesDataOnSetTimeIterator struct {
	Event *FilesDataOnSetTime // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnSetTimeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnSetTime)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnSetTime)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnSetTimeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnSetTimeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnSetTime represents a OnSetTime event raised by the FilesData contract.
type FilesDataOnSetTime struct {
	Uuid [16]byte
	Time *big.Int
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterOnSetTime is a free log retrieval operation binding the contract event 0x50843b091ea0bec4b6ead7f725b4fcb769671b6948c77b9cd98b25ff2440d84c.
//
// Solidity: e onSetTime(uuid bytes16, time uint256)
func (_FilesData *FilesDataFilterer) FilterOnSetTime(opts *bind.FilterOpts) (*FilesDataOnSetTimeIterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onSetTime")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnSetTimeIterator{contract: _FilesData.contract, event: "onSetTime", logs: logs, sub: sub}, nil
}

// WatchOnSetTime is a free log subscription operation binding the contract event 0x50843b091ea0bec4b6ead7f725b4fcb769671b6948c77b9cd98b25ff2440d84c.
//
// Solidity: e onSetTime(uuid bytes16, time uint256)
func (_FilesData *FilesDataFilterer) WatchOnSetTime(opts *bind.WatchOpts, sink chan<- *FilesDataOnSetTime) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onSetTime")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnSetTime)
				if err := _FilesData.contract.UnpackLog(event, "onSetTime", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// FilesDataOnSetUploaderUuidIterator is returned from FilterOnSetUploaderUuid and is used to iterate over the raw logs and unpacked data for OnSetUploaderUuid events raised by the FilesData contract.
type FilesDataOnSetUploaderUuidIterator struct {
	Event *FilesDataOnSetUploaderUuid // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *FilesDataOnSetUploaderUuidIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(FilesDataOnSetUploaderUuid)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(FilesDataOnSetUploaderUuid)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *FilesDataOnSetUploaderUuidIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *FilesDataOnSetUploaderUuidIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// FilesDataOnSetUploaderUuid represents a OnSetUploaderUuid event raised by the FilesData contract.
type FilesDataOnSetUploaderUuid struct {
	Uuid         [16]byte
	UploaderUuid [16]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterOnSetUploaderUuid is a free log retrieval operation binding the contract event 0xd8aaf341152319250a5bbe3f879ed37a1710d2b5dfa9676f68e9bfb98e3de630.
//
// Solidity: e onSetUploaderUuid(uuid bytes16, uploaderUuid bytes16)
func (_FilesData *FilesDataFilterer) FilterOnSetUploaderUuid(opts *bind.FilterOpts) (*FilesDataOnSetUploaderUuidIterator, error) {

	logs, sub, err := _FilesData.contract.FilterLogs(opts, "onSetUploaderUuid")
	if err != nil {
		return nil, err
	}
	return &FilesDataOnSetUploaderUuidIterator{contract: _FilesData.contract, event: "onSetUploaderUuid", logs: logs, sub: sub}, nil
}

// WatchOnSetUploaderUuid is a free log subscription operation binding the contract event 0xd8aaf341152319250a5bbe3f879ed37a1710d2b5dfa9676f68e9bfb98e3de630.
//
// Solidity: e onSetUploaderUuid(uuid bytes16, uploaderUuid bytes16)
func (_FilesData *FilesDataFilterer) WatchOnSetUploaderUuid(opts *bind.WatchOpts, sink chan<- *FilesDataOnSetUploaderUuid) (event.Subscription, error) {

	logs, sub, err := _FilesData.contract.WatchLogs(opts, "onSetUploaderUuid")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(FilesDataOnSetUploaderUuid)
				if err := _FilesData.contract.UnpackLog(event, "onSetUploaderUuid", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}
